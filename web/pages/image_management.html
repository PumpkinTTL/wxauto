<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCRå›¾åƒè¯†åˆ«</title>
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #f8fafc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* é¡µé¢å®¹å™¨ */
        .page-container {
            padding: 16px;
            height: calc(100vh - 32px);
            overflow-y: auto;
        }

        /* å¡ç‰‡æ ·å¼ */
        .content-card {
            background: white;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* å¤´éƒ¨æ ·å¼ */
        .page-header {
            padding: 16px 20px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
        }





        /* å·¥å…·æ æ ·å¼ */
        .toolbar {
            padding: 16px 20px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .filter-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        /* è¡¨æ ¼å®¹å™¨ */
        .table-container {
            padding: 0 20px 20px 20px;
            min-height: 400px;
            background: white;
            border-radius: 8px;
        }

        /* å¼ºåˆ¶è¡¨æ ¼æ˜¾ç¤º */
        .el-table {
            display: table !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* å›¾ç‰‡é¢„è§ˆæ ·å¼ */
        .image-preview {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .image-preview:hover {
            transform: scale(1.05);
        }

        .no-image {
            width: 50px;
            height: 50px;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 10px;
            border: 1px solid #e5e7eb;
        }

        .image-container {
            position: relative;
            width: 50px;
            height: 50px;
        }

        .loading-image {
            width: 50px;
            height: 50px;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 9px;
            border: 1px solid #e5e7eb;
        }

        /* çŠ¶æ€æ ‡ç­¾æ ·å¼ */
        .status-enabled {
            background: #dcfce7;
            color: #166534;
        }

        .status-disabled {
            background: #fee2e2;
            color: #991b1b;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .animate-fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* è¡¨å•æ ·å¼ä¼˜åŒ– */
        .el-form-item__label {
            font-weight: 500;
        }



        /* ç®€åŒ–æ ·å¼ï¼Œä½¿ç”¨Element Plusé»˜è®¤æ ·å¼ */

        /* æ“ä½œæŒ‰é’®ç»„ */
        .action-buttons {
            display: flex;
            gap: 8px;
        }

        /* å›¾ç‰‡é¢„è§ˆå¯¹è¯æ¡† */
        .image-preview-dialog .el-dialog__body {
            text-align: center;
            padding: 20px;
        }

        .preview-image {
            max-width: 100%;
            max-height: 500px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* ç®€æ´ç°ä»£é¡µé¢å¤´éƒ¨ */
        .page-header {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            margin-bottom: 24px;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .animate-fade-in-up {
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .page-container {
                padding: 10px;
            }

            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-group {
                justify-content: center;
            }




        }
    </style>
</head>

<body>
    <div id="app">
        <div class="page-container animate-fade-in">
            <!-- é¡µé¢å¤´éƒ¨ -->
            <div class="content-card page-header">
                <!-- OCRå›¾åƒè¯†åˆ«è¯´æ˜ -->
                <el-tag type="info" size="large" style="margin: 16px 0;">
                    OCRå›¾åƒè¯†åˆ«è¯´æ˜ï¼šå›¾ç‰‡ä¸Šä¼ æ˜¯ä¸ºäº†æ–¹ä¾¿é€šè¿‡OCR(å›¾åƒè§†è§‰è¯†åˆ«)æ¥è¯†åˆ«ç›´æ’­é—´æ˜¯å¦å­˜åœ¨è·Ÿè‡ªå·±äº§å“ç›¸å…³çš„ä¿¡æ¯ï¼Œå¦‚æœå­˜åœ¨çš„è¯å³ä»£è¡¨æ­£åœ¨å¸¦è´§è‡ªå·±çš„äº§å“ï¼Œæ‰€ä»¥ä¸€ä¸ªç›´æ’­é—´çš„å›¾ç‰‡è¯†åˆ«ä¸é™äºå•†å“çš„å›¾ç‰‡ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªä»·æ ¼æ ‡ç­¾ä¸€ä¸ªä¸»æ’­å¤´åƒã€‚æˆ–è€…å…¶ä»–å‡¡æ˜¯ç›´æ’­é—´å‡ºç°è¿™ä¸ªå…ƒç´ å°±ä»£è¡¨è‡ªå·±çš„äº§å“åœ¨æ¨ä¸­ï¼Œæ‰€ä»¥å¯ä»¥æˆªå–ä»»ä½•çš„æˆªå›¾ï¼Œä¸è®ºå¤§å°ä¸è®ºå†…å®¹çš„å›¾ç‰‡è§†è§‰å…ƒç´ ï¼Œåªè¦è®¤ä¸ºè¿™ä¸ªå…ƒç´ ä¸æœ¬äº§å“ç›¸å…³è·Ÿæœ¬ç›´æ’­é—´ç›¸å…³å°±å¯ä»¥è¿›è¡Œæˆªå›¾å¹¶ç»‘å®šè¯¥å•†å“ï¼Œè¯†åˆ«æˆåŠŸåæ‰ä¼šè¿›è¡Œå¼¹å¹•è£…é…å¹¶æŒ‰ç…§æŒ‡å®šé—´éš”æ—¶é—´å»å‘é€ã€‚æ‰€ä»¥å•†å“çš„åˆ›å»ºå’Œå›¾ç‰‡çš„ç»‘å®šå°¤ä¸ºçš„é‡è¦ï¼
                </el-tag>
            </div>



            <!-- ä¸»è¦å†…å®¹ -->
            <div class="content-card">
                <!-- å·¥å…·æ  -->
                <div class="toolbar">
                    <div class="filter-group">
                        <el-select
                            v-model="searchForm.product_id"
                            placeholder="é€‰æ‹©å•†å“"
                            clearable
                            size="small"
                            style="width: 160px;"
                            @change="searchImages"
                        >
                            <el-option label="å…¨éƒ¨å•†å“" value=""></el-option>
                            <el-option
                                v-for="product in productOptions"
                                :key="product.id"
                                :label="product.name"
                                :value="product.id"
                            ></el-option>
                        </el-select>

                        <el-select
                            v-model="searchForm.status"
                            placeholder="é€‰æ‹©çŠ¶æ€"
                            clearable
                            size="small"
                            style="width: 100px;"
                            @change="searchImages"
                        >
                            <el-option label="å…¨éƒ¨çŠ¶æ€" value=""></el-option>
                            <el-option label="å¯ç”¨" :value="1"></el-option>
                            <el-option label="ç¦ç”¨" :value="0"></el-option>
                        </el-select>
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <el-button size="small" type="primary" @click="searchImages" :loading="loading">
                            <el-icon><Search /></el-icon>
                            æœç´¢
                        </el-button>
                        <el-button size="small" type="success" @click="showAddDialog">
                            <el-icon><Plus /></el-icon>
                            æ·»åŠ å›¾ç‰‡
                        </el-button>
                        <el-button size="small" @click="refreshData" :loading="loading">
                            <el-icon><Refresh /></el-icon>
                            åˆ·æ–°
                        </el-button>
                    </div>
                </div>

                <!-- æ•°æ®è¡¨æ ¼ -->
                <div class="table-container">
                    <el-table
                        :data="imageList"
                        v-loading="loading"
                        element-loading-text="åŠ è½½ä¸­..."
                        stripe
                        style="width: 100%"
                        :default-sort="{ prop: 'create_time', order: 'descending' }"
                    >
                        <el-table-column prop="id" label="ID" width="80" sortable></el-table-column>
                        
                        <el-table-column label="å›¾ç‰‡é¢„è§ˆ" width="120">
                            <template #default="scope">
                                <div v-if="scope.row.path" class="image-container">
                                    <img
                                        v-if="scope.row.objectUrl"
                                        :src="scope.row.objectUrl"
                                        class="image-preview"
                                        @click="previewImageById(scope.row.id)"
                                        @error="handleImageError"
                                    />
                                    <div v-else class="loading-image">
                                        åŠ è½½ä¸­...
                                    </div>
                                </div>
                                <div v-else class="no-image">
                                    æ— å›¾ç‰‡
                                </div>
                            </template>
                        </el-table-column>
                        
                        <el-table-column prop="path" label="å›¾ç‰‡è·¯å¾„" min-width="250" show-overflow-tooltip></el-table-column>
                        
                        <el-table-column label="å…³è”å•†å“" width="150">
                            <template #default="scope">
                                <span v-if="scope.row.product_name" style="color: #3b82f6; font-weight: 500;">
                                    {{ scope.row.product_name }}
                                </span>
                                <span v-else style="color: #9ca3af;">
                                    æœªå…³è”
                                </span>
                            </template>
                        </el-table-column>
                        
                        <el-table-column label="çŠ¶æ€" width="100">
                            <template #default="scope">
                                <el-tag
                                    :type="scope.row.status === 1 ? 'success' : 'danger'"
                                    size="small"
                                    :class="scope.row.status === 1 ? 'status-enabled' : 'status-disabled'"
                                >
                                    {{ scope.row.status === 1 ? 'å¯ç”¨' : 'ç¦ç”¨' }}
                                </el-tag>
                            </template>
                        </el-table-column>
                        
                        <el-table-column prop="remark" label="å¤‡æ³¨" min-width="200" show-overflow-tooltip></el-table-column>
                        
                        <el-table-column prop="create_time" label="åˆ›å»ºæ—¶é—´" width="180" sortable>
                            <template #default="scope">
                                {{ formatDateTime(scope.row.create_time) }}
                            </template>
                        </el-table-column>
                        
                        <el-table-column label="æ“ä½œ" width="160" fixed="right">
                            <template #default="scope">
                                <div class="action-buttons">
                                    <el-button size="small" type="primary" @click="editImage(scope.row)" :loading="editLoading" link>
                                        <el-icon><Edit /></el-icon>
                                        ç¼–è¾‘
                                    </el-button>
                                    <el-button size="small" type="danger" @click="deleteImage(scope.row)" link>
                                        <el-icon><Delete /></el-icon>
                                        åˆ é™¤
                                    </el-button>
                                </div>
                            </template>
                        </el-table-column>
                    </el-table>

                    <!-- åˆ†é¡µ -->
                    <div style="margin-top: 20px; text-align: center;">
                        <el-pagination
                            v-model:current-page="pagination.page"
                            v-model:page-size="pagination.pageSize"
                            :page-sizes="[10, 20, 50, 100]"
                            :total="pagination.total"
                            layout="total, sizes, prev, pager, next, jumper"
                            @size-change="handleSizeChange"
                            @current-change="handleCurrentChange"
                        />
                    </div>
                </div>
            </div>
        </div>

        <!-- æ·»åŠ /ç¼–è¾‘å›¾ç‰‡å¯¹è¯æ¡† -->
        <el-dialog
            v-model="dialogVisible"
            :title="dialogTitle"
            width="520px"
            :close-on-click-modal="false"
        >
            <el-form
                ref="imageFormRef"
                :model="imageForm"
                :rules="imageRules"
                label-width="80px"
                label-position="left"
            >
                <el-form-item label="å›¾ç‰‡è·¯å¾„" prop="path">
                    <el-input
                        v-model="imageForm.path"
                        placeholder="å›¾ç‰‡è·¯å¾„ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰"
                        readonly
                        size="small"
                    >
                        <template #append>
                            <el-button type="primary" @click="selectImageFile" :loading="uploadingImage">
                                é€‰æ‹©å›¾ç‰‡
                            </el-button>
                        </template>
                    </el-input>
                    <div v-if="imageForm.path && imagePreviewUrl" style="margin-top: 8px; margin-bottom: 12px;">
                        <img
                            :src="imagePreviewUrl"
                            style="max-width: 160px; max-height: 120px; border: 1px solid #e5e7eb; cursor: pointer;"
                            @click="previewImage(imagePreviewUrl)"
                            @error="handleFormImageError"
                        />
                    </div>
                    <div v-if="!imageForm.path" style="margin-top: 8px;">
                        <el-tag size="small" type="info" effect="plain" style="font-size: 11px; padding: 2px 8px;">
                            <el-icon style="margin-right: 4px; font-size: 12px;"><Upload /></el-icon>
                            ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æŒ‰é’®ä¸Šä¼ æ–‡ä»¶
                        </el-tag>
                    </div>
                </el-form-item>
                
                <el-form-item label="å…³è”å•†å“" prop="product_id">
                    <el-select
                        v-model="imageForm.product_id"
                        placeholder="é€‰æ‹©å…³è”å•†å“ï¼ˆå¯é€‰ï¼‰"
                        clearable
                        style="width: 100%;"
                    >
                        <el-option
                            v-for="product in productOptions"
                            :key="product.id"
                            :label="product.name"
                            :value="product.id"
                        ></el-option>
                    </el-select>
                </el-form-item>
                
                <el-form-item label="çŠ¶æ€" prop="status">
                    <el-radio-group v-model="imageForm.status">
                        <el-radio :label="1">å¯ç”¨</el-radio>
                        <el-radio :label="0">ç¦ç”¨</el-radio>
                    </el-radio-group>
                </el-form-item>
                
                <el-form-item label="å¤‡æ³¨ä¿¡æ¯" prop="remark">
                    <el-input
                        v-model="imageForm.remark"
                        type="textarea"
                        :rows="3"
                        placeholder="è¯·è¾“å…¥å¤‡æ³¨ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰"
                        maxlength="500"
                        show-word-limit
                    />
                </el-form-item>
            </el-form>
            
            <template #footer>
                <div style="text-align: right;">
                    <el-button @click="dialogVisible = false">å–æ¶ˆ</el-button>
                    <el-button type="primary" @click="submitImage" :loading="submitLoading">
                        {{ isEdit ? 'æ›´æ–°' : 'æ·»åŠ ' }}
                    </el-button>
                </div>
            </template>
        </el-dialog>

        <!-- å›¾ç‰‡é¢„è§ˆå¯¹è¯æ¡† -->
        <el-dialog
            v-model="previewVisible"
            title="å›¾ç‰‡é¢„è§ˆ"
            width="80%"
            class="image-preview-dialog"
        >
            <img :src="previewImageUrl" class="preview-image" @error="handlePreviewError" />
        </el-dialog>
    </div>

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Element Plus -->
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue/dist/index.iife.js"></script>

    <script>
        const { createApp, ref, reactive, computed, onMounted, nextTick } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;

        const app = createApp({
            setup() {
                // è·å–pywebview API
                const getPywebviewApi = () => {
                    if (window.pywebview && window.pywebview.api) {
                        return window.pywebview.api;
                    } else if (window.parent && window.parent.pywebview && window.parent.pywebview.api) {
                        return window.parent.pywebview.api;
                    } else if (window.top && window.top.pywebview && window.top.pywebview.api) {
                        return window.top.pywebview.api;
                    }
                    return null;
                };

                // å“åº”å¼æ•°æ®
                const loading = ref(false);
                const submitLoading = ref(false);
                const uploadingImage = ref(false);
                const imageList = ref([]);
                const productOptions = ref([]);
                const dialogVisible = ref(false);
                const previewVisible = ref(false);
                const previewImageUrl = ref('');
                const isEdit = ref(false);
                const editLoading = ref(false);
                const imageFormRef = ref(null);

                // æœç´¢è¡¨å•
                const searchForm = reactive({
                    product_id: '',
                    status: ''
                });

                // åˆ†é¡µæ•°æ®
                const pagination = reactive({
                    page: 1,
                    pageSize: 20,
                    total: 0
                });

                // å›¾ç‰‡è¡¨å•
                const imageForm = reactive({
                    id: null,
                    path: '',
                    product_id: '',
                    status: 1,
                    remark: ''
                });

                // å›¾ç‰‡é¢„è§ˆURL
                const imagePreviewUrl = ref('');

                // è¡¨å•éªŒè¯è§„åˆ™
                const imageRules = {
                    path: [
                        { required: true, message: 'è¯·è¾“å…¥å›¾ç‰‡è·¯å¾„', trigger: 'blur' },
                        { min: 1, max: 500, message: 'å›¾ç‰‡è·¯å¾„é•¿åº¦åœ¨ 1 åˆ° 500 ä¸ªå­—ç¬¦', trigger: 'blur' }
                    ],
                    status: [
                        { required: true, message: 'è¯·é€‰æ‹©çŠ¶æ€', trigger: 'change' }
                    ]
                };

                // è®¡ç®—å±æ€§
                const dialogTitle = computed(() => {
                    return isEdit.value ? 'ç¼–è¾‘å›¾ç‰‡' : 'æ·»åŠ å›¾ç‰‡';
                });

                // æ–¹æ³•
                const loadImages = async () => {
                    loading.value = true;
                    try {
                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        const params = {
                            page: pagination.page,
                            page_size: pagination.pageSize,
                            product_id: searchForm.product_id || null,
                            status: searchForm.status !== '' ? searchForm.status : null
                        };

                        const result = await api.query_images_api(params);

                        if (result.success) {
                            imageList.value = result.data || [];
                            pagination.total = result.total || 0;

                            console.log('âœ… å›¾ç‰‡æ•°æ®åŠ è½½æˆåŠŸ:', {
                                count: imageList.value.length,
                                total: pagination.total,
                                data: imageList.value
                            });

                            // é¢„åŠ è½½è¡¨æ ¼å›¾ç‰‡
                            nextTick(() => {
                                loadTableImages();
                            });
                        } else {
                            console.error('âŒ å›¾ç‰‡æ•°æ®åŠ è½½å¤±è´¥:', result.message);
                            ElMessage.error(result.message || 'åŠ è½½å›¾ç‰‡åˆ—è¡¨å¤±è´¥');
                            imageList.value = [];
                            pagination.total = 0;
                        }
                    } catch (error) {
                        console.error('åŠ è½½å›¾ç‰‡åˆ—è¡¨å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½å›¾ç‰‡åˆ—è¡¨å¤±è´¥');
                        imageList.value = [];
                        pagination.total = 0;
                    } finally {
                        loading.value = false;
                    }
                };

                const loadProductOptions = async () => {
                    try {
                        const api = getPywebviewApi();
                        if (!api) return;

                        const result = await api.get_products_simple_api();
                        if (result.success) {
                            productOptions.value = result.data || [];
                        } else {
                            console.error('åŠ è½½å•†å“é€‰é¡¹å¤±è´¥:', result.message);
                            productOptions.value = [];
                        }
                    } catch (error) {
                        console.error('åŠ è½½å•†å“é€‰é¡¹å¤±è´¥:', error);
                        productOptions.value = [];
                    }
                };

                const searchImages = () => {
                    pagination.page = 1;
                    loadImages();
                };

                const refreshData = () => {
                    loadImages();
                    loadProductOptions();
                };

                const showAddDialog = () => {
                    isEdit.value = false;
                    resetForm();
                    dialogVisible.value = true;
                };

                const editImage = async (image) => {
                    editLoading.value = true;

                    try {
                        isEdit.value = true;
                        Object.assign(imageForm, {
                            id: image.id,
                            path: image.path || '',
                            product_id: image.product_id || '',
                            status: image.status !== undefined ? image.status : 1,
                            remark: image.remark || ''
                        });

                        // åŠ è½½å›¾ç‰‡é¢„è§ˆ
                        if (image.path) {
                            try {
                                const api = getPywebviewApi();
                                if (api) {
                                    const previewResult = await api.get_image_data_url(image.path);
                                    if (previewResult.success) {
                                        imagePreviewUrl.value = previewResult.data_url;
                                    }
                                }
                            } catch (error) {
                                console.error('åŠ è½½å›¾ç‰‡é¢„è§ˆå¤±è´¥:', error);
                            }
                        }

                        dialogVisible.value = true;
                    } finally {
                        editLoading.value = false;
                    }
                };

                const resetForm = () => {
                    Object.assign(imageForm, {
                        id: null,
                        path: '',
                        product_id: '',
                        status: 1,
                        remark: ''
                    });
                    imagePreviewUrl.value = ''; // æ¸…ç©ºé¢„è§ˆURL
                    if (imageFormRef.value) {
                        imageFormRef.value.clearValidate();
                    }
                };

                const submitImage = async () => {
                    if (!imageFormRef.value) return;

                    try {
                        const valid = await imageFormRef.value.validate();
                        if (!valid) return;
                    } catch (error) {
                        return;
                    }

                    const api = getPywebviewApi();
                    if (!api) {
                        ElMessage.error('APIä¸å¯ç”¨');
                        return;
                    }

                    submitLoading.value = true;
                    try {
                        const imageData = {
                            path: imageForm.path.trim(),
                            product_id: imageForm.product_id || null,
                            status: imageForm.status,
                            remark: imageForm.remark.trim()
                        };

                        let result;
                        if (isEdit.value) {
                            imageData.id = imageForm.id;
                            result = await api.update_image_api(imageData);
                        } else {
                            result = await api.add_image_api(imageData);
                        }

                        if (result.success) {
                            ElMessage.success(result.message || (isEdit.value ? 'å›¾ç‰‡æ›´æ–°æˆåŠŸ' : 'å›¾ç‰‡æ·»åŠ æˆåŠŸ'));
                            dialogVisible.value = false;
                            loadImages();
                        } else {
                            ElMessage.error(result.message || (isEdit.value ? 'å›¾ç‰‡æ›´æ–°å¤±è´¥' : 'å›¾ç‰‡æ·»åŠ å¤±è´¥'));
                        }
                    } catch (error) {
                        console.error('æäº¤å›¾ç‰‡å¤±è´¥:', error);
                        ElMessage.error(isEdit.value ? 'å›¾ç‰‡æ›´æ–°å¤±è´¥' : 'å›¾ç‰‡æ·»åŠ å¤±è´¥');
                    } finally {
                        submitLoading.value = false;
                    }
                };

                const deleteImage = async (image) => {
                    try {
                        await ElMessageBox.confirm(
                            `ç¡®å®šè¦åˆ é™¤è¿™å¼ å›¾ç‰‡å—ï¼Ÿ`,
                            'ç¡®è®¤åˆ é™¤',
                            {
                                confirmButtonText: 'ç¡®å®šåˆ é™¤',
                                cancelButtonText: 'å–æ¶ˆ',
                                type: 'warning',
                                confirmButtonClass: 'el-button--danger'
                            }
                        );

                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        const result = await api.delete_image_api(image.id);

                        if (result.success) {
                            ElMessage.success(result.message || 'å›¾ç‰‡åˆ é™¤æˆåŠŸ');
                            loadImages();
                        } else {
                            ElMessage.error(result.message || 'å›¾ç‰‡åˆ é™¤å¤±è´¥');
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤å›¾ç‰‡å¤±è´¥:', error);
                            ElMessage.error('å›¾ç‰‡åˆ é™¤å¤±è´¥');
                        }
                    }
                };

                const previewImage = (imageUrl) => {
                    previewImageUrl.value = imageUrl;
                    previewVisible.value = true;
                };

                const handleSizeChange = (size) => {
                    pagination.pageSize = size;
                    pagination.page = 1;
                    loadImages();
                };

                const handleCurrentChange = (page) => {
                    pagination.page = page;
                    loadImages();
                };

                const formatDateTime = (dateTime) => {
                    if (!dateTime) return '-';
                    try {
                        const date = new Date(dateTime);
                        return date.toLocaleString('zh-CN', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    } catch (error) {
                        return dateTime;
                    }
                };

                const handleImageError = (event) => {
                    event.target.style.display = 'none';
                    const noImageDiv = document.createElement('div');
                    noImageDiv.className = 'no-image';
                    noImageDiv.textContent = 'åŠ è½½å¤±è´¥';
                    event.target.parentNode.appendChild(noImageDiv);
                };

                const handlePreviewError = () => {
                    ElMessage.error('å›¾ç‰‡é¢„è§ˆå¤±è´¥');
                };

                const selectImageFile = async () => {
                    try {
                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        uploadingImage.value = true;

                        // é€‰æ‹©å›¾ç‰‡æ–‡ä»¶
                        const selectResult = await api.select_image_file();
                        if (!selectResult.success) {
                            if (selectResult.message !== 'æœªé€‰æ‹©æ–‡ä»¶') {
                                ElMessage.error(selectResult.message);
                            }
                            return;
                        }

                        // ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶
                        const uploadResult = await api.upload_image_file(
                            selectResult.file_path,
                            selectResult.filename
                        );

                        if (uploadResult.success) {
                            imageForm.path = uploadResult.path;

                            // ç«‹å³åŠ è½½å›¾ç‰‡é¢„è§ˆ
                            try {
                                const previewResult = await api.get_image_data_url(uploadResult.path);
                                if (previewResult.success) {
                                    imagePreviewUrl.value = previewResult.data_url;
                                }
                            } catch (error) {
                                console.error('åŠ è½½å›¾ç‰‡é¢„è§ˆå¤±è´¥:', error);
                            }

                            ElMessage.success('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ');
                        } else {
                            ElMessage.error(uploadResult.message || 'å›¾ç‰‡ä¸Šä¼ å¤±è´¥');
                        }

                    } catch (error) {
                        console.error('é€‰æ‹©å›¾ç‰‡å¤±è´¥:', error);
                        ElMessage.error('é€‰æ‹©å›¾ç‰‡å¤±è´¥');
                    } finally {
                        uploadingImage.value = false;
                    }
                };

                const loadImagePreviews = async () => {
                    const api = getPywebviewApi();
                    if (!api) return;

                    for (const image of imageList.value) {
                        if (image.path) {
                            try {
                                const result = await api.get_image_data_url(image.path);
                                if (result.success) {
                                    // æ‰¾åˆ°å¯¹åº”çš„imgå…ƒç´ å¹¶è®¾ç½®src
                                    const imgElement = document.querySelector(`img[ref="image-${image.id}"]`);
                                    if (imgElement) {
                                        imgElement.src = result.data_url;
                                        imgElement.style.display = 'block';
                                        // éšè—åŠ è½½æç¤º
                                        const loadingElement = imgElement.parentNode.querySelector('.loading-image');
                                        if (loadingElement) {
                                            loadingElement.style.display = 'none';
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('åŠ è½½å›¾ç‰‡é¢„è§ˆå¤±è´¥:', error);
                            }
                        }
                    }
                };

                const previewImageById = async (imageId) => {
                    const api = getPywebviewApi();
                    if (!api) return;

                    const image = imageList.value.find(img => img.id === imageId);
                    if (image && image.path) {
                        try {
                            const result = await api.get_image_data_url(image.path);
                            if (result.success) {
                                previewImage(result.data_url);
                            } else {
                                ElMessage.error('æ— æ³•é¢„è§ˆå›¾ç‰‡');
                            }
                        } catch (error) {
                            console.error('é¢„è§ˆå›¾ç‰‡å¤±è´¥:', error);
                            ElMessage.error('é¢„è§ˆå›¾ç‰‡å¤±è´¥');
                        }
                    }
                };

                const getImageUrl = async (imagePath) => {
                    if (!imagePath) return '';

                    // å¦‚æœæ˜¯ç½‘ç»œå›¾ç‰‡ï¼Œç›´æ¥è¿”å›
                    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                        return imagePath;
                    }

                    const api = getPywebviewApi();
                    if (!api) return '';

                    try {
                        // é€šè¿‡APIè·å–å›¾ç‰‡æ•°æ®URL
                        const result = await api.get_image_data_url(imagePath);
                        if (result.success) {
                            return result.data_url;
                        } else {
                            console.error('è·å–å›¾ç‰‡å¤±è´¥:', result.message);
                            return '';
                        }
                    } catch (error) {
                        console.error('è·å–å›¾ç‰‡å¤±è´¥:', error);
                        return '';
                    }
                };

                // å›¾ç‰‡URLç¼“å­˜
                const imageUrlCache = new Map();

                const getTableImageUrl = async (imagePath) => {
                    if (!imagePath) return '';

                    // å¦‚æœæ˜¯ç½‘ç»œå›¾ç‰‡ï¼Œç›´æ¥è¿”å›
                    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                        return imagePath;
                    }

                    // æ£€æŸ¥ç¼“å­˜
                    if (imageUrlCache.has(imagePath)) {
                        return imageUrlCache.get(imagePath);
                    }

                    // é€šè¿‡APIè·å–æ–‡ä»¶Blob
                    const api = getPywebviewApi();
                    if (!api) return '';

                    try {
                        const result = await api.get_image_blob(imagePath);
                        if (result.success && result.blob_data) {
                            // å°†base64è½¬æ¢ä¸ºBlob
                            const byteCharacters = atob(result.blob_data);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: result.mime_type || 'image/jpeg' });

                            // åˆ›å»ºObject URL
                            const objectUrl = URL.createObjectURL(blob);
                            imageUrlCache.set(imagePath, objectUrl);
                            return objectUrl;
                        }
                    } catch (error) {
                        console.error('è·å–å›¾ç‰‡å¤±è´¥:', error);
                    }

                    return '';
                };

                const loadTableImages = async () => {
                    console.log('ğŸ–¼ï¸ å¼€å§‹åŠ è½½è¡¨æ ¼å›¾ç‰‡...');

                    for (const image of imageList.value) {
                        if (image.path && !image.objectUrl) {
                            try {
                                const objectUrl = await getTableImageUrl(image.path);
                                if (objectUrl) {
                                    image.objectUrl = objectUrl;
                                }
                            } catch (error) {
                                console.error('åŠ è½½è¡¨æ ¼å›¾ç‰‡å¤±è´¥:', image.path, error);
                            }
                        }
                    }

                    console.log('âœ… è¡¨æ ¼å›¾ç‰‡åŠ è½½å®Œæˆ');
                };

                const handleFormImageError = (event) => {
                    handleImageError(event);
                };

                // ç”Ÿå‘½å‘¨æœŸ
                onMounted(() => {
                    console.log('ğŸš€ OCRå›¾åƒè¯†åˆ«é¡µé¢å·²æŒ‚è½½ï¼Œå¼€å§‹åŠ è½½æ•°æ®...');
                    console.log('ğŸ“Š å½“å‰imageListçŠ¶æ€:', imageList.value);
                    console.log('ğŸ“Š å½“å‰loadingçŠ¶æ€:', loading.value);

                    loadImages();
                    loadProductOptions();
                });

                return {
                    loading,
                    submitLoading,
                    uploadingImage,
                    imageList,
                    productOptions,
                    dialogVisible,
                    previewVisible,
                    previewImageUrl,
                    isEdit,
                    imageFormRef,
                    searchForm,
                    pagination,
                    imageForm,
                    imageRules,
                    dialogTitle,
                    loadImages,
                    loadProductOptions,
                    searchImages,
                    refreshData,
                    showAddDialog,
                    editImage,
                    resetForm,
                    submitImage,
                    deleteImage,
                    previewImage,
                    handleSizeChange,
                    handleCurrentChange,
                    formatDateTime,
                    handleImageError,
                    handlePreviewError,
                    loadImagePreviews,
                    previewImageById,
                    selectImageFile,
                    getImageUrl,
                    getTableImageUrl,
                    loadTableImages,
                    editLoading,
                    handleFormImageError,
                    imagePreviewUrl
                };
            }
        });

        // æ³¨å†Œæ‰€æœ‰å›¾æ ‡
        Object.keys(ElementPlusIconsVue).forEach(key => {
            app.component(key, ElementPlusIconsVue[key]);
        });

        app.use(ElementPlus).mount('#app');
    </script>
</body>

</html>
