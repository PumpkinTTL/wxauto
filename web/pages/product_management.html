<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•†å“ç®¡ç†</title>
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #f8fafc;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* é¡µé¢å®¹å™¨ */
        .page-container {
            padding: 16px;
            height: calc(100vh - 32px);
            overflow-y: auto;
        }

        /* å¡ç‰‡æ ·å¼ */
        .content-card {
            background: white;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* å¤´éƒ¨æ ·å¼ */
        .page-header {
            padding: 16px 20px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
        }

        .page-title {
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 4px 0;
            color: #1f2937;
        }

        .page-subtitle {
            font-size: 13px;
            margin: 0;
            color: #6b7280;
        }

        /* å·¥å…·æ æ ·å¼ */
        .toolbar {
            padding: 16px 20px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .search-box {
            flex: 1;
            max-width: 280px;
        }

        /* è¡¨æ ¼å®¹å™¨ */
        .table-container {
            padding: 0 20px 20px 20px;
            min-height: 400px;
            background: white;
            border-radius: 8px;
        }

        /* å¼ºåˆ¶è¡¨æ ¼æ˜¾ç¤º */
        .el-table {
            display: table !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* å•†å“å°é¢å›¾ç‰‡æ ·å¼ */
        .product-cover {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border: 1px solid #e5e7eb;
        }

        .no-cover {
            width: 40px;
            height: 40px;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 10px;
            border: 1px solid #e5e7eb;
        }

        .image-container {
            position: relative;
            width: 60px;
            height: 60px;
        }

        .loading-cover {
            width: 60px;
            height: 60px;
            background: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 10px;
            border: 1px solid #e5e7eb;
        }

        /* ä»·æ ¼æ ·å¼ */
        .price-text {
            color: #ef4444;
            font-weight: 600;
            font-size: 16px;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .animate-fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* è¡¨å•æ ·å¼ä¼˜åŒ– */
        .el-form-item__label {
            font-weight: 500;
        }



        /* ç®€åŒ–æ ·å¼ï¼Œä½¿ç”¨Element Plusé»˜è®¤æ ·å¼ */

        /* çŠ¶æ€æ ‡ç­¾æ ·å¼ */
        .status-tag {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
        }

        /* æ“ä½œæŒ‰é’®ç»„ */
        .action-buttons {
            display: flex;
            gap: 8px;
        }

        /* ç®€æ´ç°ä»£é¡µé¢å¤´éƒ¨ */
        .page-header {
            background: #ffffff;
            color: #1f2937;
            border: 1px solid #e5e7eb;
            margin-bottom: 24px;
            padding: 20px 24px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .page-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .page-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0;
            color: #111827;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .page-title i {
            font-size: 24px;
            color: #10b981;
        }

        .page-subtitle {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            font-weight: 400;
        }

        .page-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* åŠŸèƒ½æ ‡ç­¾ */
        .feature-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #f3f4f6;
            color: #6b7280;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .feature-tag.active {
            background: #d1fae5;
            color: #065f46;
        }

        .feature-tag i {
            font-size: 14px;
        }

        /* çŠ¶æ€å›¾æ ‡ */
        .status-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: #f9fafb;
            color: #6b7280;
            font-size: 16px;
        }

        .status-icon.success {
            background: #dcfce7;
            color: #16a34a;
        }

        .status-icon.info {
            background: #dbeafe;
            color: #2563eb;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .page-container {
                padding: 10px;
            }

            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }

            .search-box {
                max-width: none;
            }

            .page-title {
                font-size: 24px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="page-container animate-fade-in">
            <!-- é¡µé¢å¤´éƒ¨ -->
            <div class="content-card page-header">
                <div class="page-header-left">
                    <h1 class="page-title">
                        <i class="el-icon-goods"></i>
                        å•†å“ç®¡ç†
                    </h1>
                    <p class="page-subtitle">ç®¡ç†å•†å“ä¿¡æ¯ï¼Œæ”¯æŒå›¾åƒè¯†åˆ«åŠŸèƒ½çš„å•†å“æ•°æ®ç»´æŠ¤</p>
                </div>

                <div class="page-header-right">
                    <div class="feature-tag active">
                        <i class="el-icon-shopping-cart-2"></i>
                        å•†å“åº“å­˜
                    </div>
                    <div class="feature-tag">
                        <i class="el-icon-picture"></i>
                        å°é¢ç®¡ç†
                    </div>
                    <div class="feature-tag">
                        <i class="el-icon-price-tag"></i>
                        ä»·æ ¼è®¾ç½®
                    </div>
                    <div class="status-icon info">
                        <i class="el-icon-data-line"></i>
                    </div>
                </div>
            </div>

            <!-- ä¸»è¦å†…å®¹ -->
            <div class="content-card">
                <!-- å·¥å…·æ  -->
                <div class="toolbar">
                    <div class="search-box">
                        <el-input
                            v-model="searchForm.name"
                            placeholder="æœç´¢å•†å“åç§°..."
                            clearable
                            @keyup.enter="searchProducts"
                            @clear="searchProducts"
                        >
                            <template #prefix>
                                <el-icon><Search /></el-icon>
                            </template>
                        </el-input>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <el-button size="small" type="primary" @click="searchProducts" :loading="loading">
                            <el-icon><Search /></el-icon>
                            æœç´¢
                        </el-button>
                        <el-button size="small" type="success" @click="showAddDialog">
                            <el-icon><Plus /></el-icon>
                            æ·»åŠ å•†å“
                        </el-button>
                        <el-button size="small" @click="refreshData" :loading="loading">
                            <el-icon><Refresh /></el-icon>
                            åˆ·æ–°
                        </el-button>
                    </div>
                </div>

                <!-- æ•°æ®è¡¨æ ¼ -->
                <div class="table-container">
                    <el-table
                        :data="productList"
                        v-loading="loading"
                        element-loading-text="åŠ è½½ä¸­..."
                        stripe
                        style="width: 100%"
                        :default-sort="{ prop: 'create_time', order: 'descending' }"
                    >
                        <el-table-column prop="id" label="ID" width="80" sortable></el-table-column>
                        
                        <el-table-column label="å•†å“å°é¢" width="100">
                            <template #default="scope">
                                <div v-if="scope.row.cover" class="image-container">
                                    <img
                                        v-if="scope.row.coverObjectUrl"
                                        :src="scope.row.coverObjectUrl"
                                        class="product-cover"
                                        @error="handleImageError"
                                    />
                                    <div v-else class="loading-cover">
                                        åŠ è½½ä¸­...
                                    </div>
                                </div>
                                <div v-else class="no-cover">
                                    æ— å°é¢
                                </div>
                            </template>
                        </el-table-column>
                        
                        <el-table-column prop="name" label="å•†å“åç§°" min-width="200" show-overflow-tooltip>
                            <template #default="scope">
                                <span style="font-weight: 500;">{{ scope.row.name }}</span>
                            </template>
                        </el-table-column>
                        
                        <el-table-column prop="price" label="ä»·æ ¼" width="120" sortable>
                            <template #default="scope">
                                <span class="price-text">Â¥{{ parseFloat(scope.row.price || 0).toFixed(2) }}</span>
                            </template>
                        </el-table-column>
                        
                        <el-table-column prop="remark" label="å¤‡æ³¨" min-width="200" show-overflow-tooltip></el-table-column>
                        
                        <el-table-column prop="create_time" label="åˆ›å»ºæ—¶é—´" width="180" sortable>
                            <template #default="scope">
                                {{ formatDateTime(scope.row.create_time) }}
                            </template>
                        </el-table-column>
                        
                        <el-table-column label="æ“ä½œ" width="160" fixed="right">
                            <template #default="scope">
                                <div class="action-buttons">
                                    <el-button size="small" type="primary" @click="editProduct(scope.row)" :loading="editLoading" link>
                                        <el-icon><Edit /></el-icon>
                                        ç¼–è¾‘
                                    </el-button>
                                    <el-button size="small" type="danger" @click="deleteProduct(scope.row)" link>
                                        <el-icon><Delete /></el-icon>
                                        åˆ é™¤
                                    </el-button>
                                </div>
                            </template>
                        </el-table-column>
                    </el-table>

                    <!-- åˆ†é¡µ -->
                    <div style="margin-top: 20px; text-align: center;">
                        <el-pagination
                            v-model:current-page="pagination.page"
                            v-model:page-size="pagination.pageSize"
                            :page-sizes="[10, 20, 50, 100]"
                            :total="pagination.total"
                            layout="total, sizes, prev, pager, next, jumper"
                            @size-change="handleSizeChange"
                            @current-change="handleCurrentChange"
                        />
                    </div>
                </div>
            </div>
        </div>

        <!-- æ·»åŠ /ç¼–è¾‘å•†å“å¯¹è¯æ¡† -->
        <el-dialog
            v-model="dialogVisible"
            :title="dialogTitle"
            width="520px"
            :close-on-click-modal="false"
        >
            <el-form
                ref="productFormRef"
                :model="productForm"
                :rules="productRules"
                label-width="80px"
                label-position="left"
            >
                <el-form-item label="å•†å“åç§°" prop="name">
                    <el-input
                        v-model="productForm.name"
                        placeholder="è¯·è¾“å…¥å•†å“åç§°"
                        maxlength="100"
                        show-word-limit
                    />
                </el-form-item>
                
                <el-form-item label="å•†å“å°é¢" prop="cover">
                    <el-input
                        v-model="productForm.cover"
                        placeholder="å›¾ç‰‡è·¯å¾„ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰"
                        readonly
                        size="small"
                    >
                        <template #append>
                            <el-button type="primary" @click="selectCoverImage" :loading="uploadingCover">
                                é€‰æ‹©å›¾ç‰‡
                            </el-button>
                        </template>
                    </el-input>
                    <div v-if="productForm.cover && coverPreviewUrl" style="margin-top: 8px; margin-bottom: 12px;">
                        <img
                            :src="coverPreviewUrl"
                            style="max-width: 160px; max-height: 120px; border: 1px solid #e5e7eb;"
                            @error="handleCoverImageError"
                        />
                    </div>
                    <div v-if="!productForm.cover" style="margin-top: 8px;">
                        <el-tag size="small" type="success" effect="plain" style="font-size: 11px; padding: 2px 8px;">
                            <el-icon style="margin-right: 4px; font-size: 12px;"><Upload /></el-icon>
                            ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æŒ‰é’®ä¸Šä¼ å°é¢
                        </el-tag>
                    </div>
                </el-form-item>
                
                <el-form-item label="å•†å“ä»·æ ¼" prop="price">
                    <el-input-number
                        v-model="productForm.price"
                        :min="0"
                        :precision="2"
                        :step="0.01"
                        placeholder="0.00"
                        style="width: 100%;"
                    />
                </el-form-item>
                
                <el-form-item label="å¤‡æ³¨ä¿¡æ¯" prop="remark">
                    <el-input
                        v-model="productForm.remark"
                        type="textarea"
                        :rows="3"
                        placeholder="è¯·è¾“å…¥å¤‡æ³¨ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰"
                        maxlength="500"
                        show-word-limit
                    />
                </el-form-item>
            </el-form>
            
            <template #footer>
                <div style="text-align: right;">
                    <el-button @click="dialogVisible = false">å–æ¶ˆ</el-button>
                    <el-button type="primary" @click="submitProduct" :loading="submitLoading">
                        {{ isEdit ? 'æ›´æ–°' : 'æ·»åŠ ' }}
                    </el-button>
                </div>
            </template>
        </el-dialog>
    </div>

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Element Plus -->
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue/dist/index.iife.js"></script>

    <script>
        const { createApp, ref, reactive, computed, onMounted, nextTick } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;

        const app = createApp({
            setup() {
                // è·å–pywebview API
                const getPywebviewApi = () => {
                    if (window.pywebview && window.pywebview.api) {
                        return window.pywebview.api;
                    } else if (window.parent && window.parent.pywebview && window.parent.pywebview.api) {
                        return window.parent.pywebview.api;
                    } else if (window.top && window.top.pywebview && window.top.pywebview.api) {
                        return window.top.pywebview.api;
                    }
                    return null;
                };

                // å“åº”å¼æ•°æ®
                const loading = ref(false);
                const submitLoading = ref(false);
                const uploadingCover = ref(false);
                const productList = ref([]);
                const dialogVisible = ref(false);
                const isEdit = ref(false);
                const editLoading = ref(false);
                const productFormRef = ref(null);

                // æœç´¢è¡¨å•
                const searchForm = reactive({
                    name: ''
                });

                // åˆ†é¡µæ•°æ®
                const pagination = reactive({
                    page: 1,
                    pageSize: 20,
                    total: 0
                });

                // å•†å“è¡¨å•
                const productForm = reactive({
                    id: null,
                    name: '',
                    cover: '',
                    price: 0.00,
                    remark: ''
                });

                // å°é¢å›¾ç‰‡é¢„è§ˆURL
                const coverPreviewUrl = ref('');

                // è¡¨å•éªŒè¯è§„åˆ™
                const productRules = {
                    name: [
                        { required: true, message: 'è¯·è¾“å…¥å•†å“åç§°', trigger: 'blur' },
                        { min: 1, max: 100, message: 'å•†å“åç§°é•¿åº¦åœ¨ 1 åˆ° 100 ä¸ªå­—ç¬¦', trigger: 'blur' }
                    ],
                    price: [
                        { required: true, message: 'è¯·è¾“å…¥å•†å“ä»·æ ¼', trigger: 'blur' },
                        { type: 'number', min: 0, message: 'ä»·æ ¼ä¸èƒ½å°äº0', trigger: 'blur' }
                    ]
                };

                // è®¡ç®—å±æ€§
                const dialogTitle = computed(() => {
                    return isEdit.value ? 'ç¼–è¾‘å•†å“' : 'æ·»åŠ å•†å“';
                });

                // æ–¹æ³•
                const loadProducts = async () => {
                    loading.value = true;
                    try {
                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        const params = {
                            page: pagination.page,
                            page_size: pagination.pageSize,
                            search_name: searchForm.name.trim()
                        };

                        const result = await api.query_products_api(params);
                        
                        if (result.success) {
                            productList.value = result.data || [];
                            pagination.total = result.total || 0;

                            console.log('âœ… å•†å“æ•°æ®åŠ è½½æˆåŠŸ:', {
                                count: productList.value.length,
                                total: pagination.total,
                                data: productList.value
                            });

                            // é¢„åŠ è½½è¡¨æ ¼å°é¢å›¾ç‰‡
                            nextTick(() => {
                                loadTableCovers();
                            });
                        } else {
                            console.error('âŒ å•†å“æ•°æ®åŠ è½½å¤±è´¥:', result.message);
                            ElMessage.error(result.message || 'åŠ è½½å•†å“åˆ—è¡¨å¤±è´¥');
                            productList.value = [];
                            pagination.total = 0;
                        }
                    } catch (error) {
                        console.error('åŠ è½½å•†å“åˆ—è¡¨å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½å•†å“åˆ—è¡¨å¤±è´¥');
                        productList.value = [];
                        pagination.total = 0;
                    } finally {
                        loading.value = false;
                    }
                };

                const searchProducts = () => {
                    pagination.page = 1;
                    loadProducts();
                };

                const refreshData = () => {
                    loadProducts();
                };

                const showAddDialog = () => {
                    isEdit.value = false;
                    resetForm();
                    dialogVisible.value = true;
                };

                const editProduct = async (product) => {
                    editLoading.value = true;

                    try {
                        isEdit.value = true;
                        Object.assign(productForm, {
                            id: product.id,
                            name: product.name || '',
                            cover: product.cover || '',
                            price: parseFloat(product.price || 0),
                            remark: product.remark || ''
                        });

                        // åŠ è½½å°é¢å›¾ç‰‡é¢„è§ˆ
                        if (product.cover) {
                            try {
                                const api = getPywebviewApi();
                                if (api) {
                                    const previewResult = await api.get_image_data_url(product.cover);
                                    if (previewResult.success) {
                                        coverPreviewUrl.value = previewResult.data_url;
                                    }
                                }
                            } catch (error) {
                                console.error('åŠ è½½å°é¢å›¾ç‰‡é¢„è§ˆå¤±è´¥:', error);
                            }
                        }

                        dialogVisible.value = true;
                    } finally {
                        editLoading.value = false;
                    }
                };

                const resetForm = () => {
                    Object.assign(productForm, {
                        id: null,
                        name: '',
                        cover: '',
                        price: 0.00,
                        remark: ''
                    });
                    coverPreviewUrl.value = ''; // æ¸…ç©ºå°é¢é¢„è§ˆURL
                    if (productFormRef.value) {
                        productFormRef.value.clearValidate();
                    }
                };

                const submitProduct = async () => {
                    if (!productFormRef.value) return;

                    try {
                        const valid = await productFormRef.value.validate();
                        if (!valid) return;
                    } catch (error) {
                        return;
                    }

                    const api = getPywebviewApi();
                    if (!api) {
                        ElMessage.error('APIä¸å¯ç”¨');
                        return;
                    }

                    submitLoading.value = true;
                    try {
                        const productData = {
                            name: productForm.name.trim(),
                            cover: productForm.cover.trim(),
                            price: productForm.price,
                            remark: productForm.remark.trim()
                        };

                        let result;
                        if (isEdit.value) {
                            productData.id = productForm.id;
                            result = await api.update_product_api(productData);
                        } else {
                            result = await api.add_product_api(productData);
                        }

                        if (result.success) {
                            ElMessage.success(result.message || (isEdit.value ? 'å•†å“æ›´æ–°æˆåŠŸ' : 'å•†å“æ·»åŠ æˆåŠŸ'));
                            dialogVisible.value = false;
                            loadProducts();
                        } else {
                            ElMessage.error(result.message || (isEdit.value ? 'å•†å“æ›´æ–°å¤±è´¥' : 'å•†å“æ·»åŠ å¤±è´¥'));
                        }
                    } catch (error) {
                        console.error('æäº¤å•†å“å¤±è´¥:', error);
                        ElMessage.error(isEdit.value ? 'å•†å“æ›´æ–°å¤±è´¥' : 'å•†å“æ·»åŠ å¤±è´¥');
                    } finally {
                        submitLoading.value = false;
                    }
                };

                const deleteProduct = async (product) => {
                    try {
                        await ElMessageBox.confirm(
                            `ç¡®å®šè¦åˆ é™¤å•†å“ "${product.name}" å—ï¼Ÿåˆ é™¤åå…³è”çš„å›¾ç‰‡å°†è§£é™¤å…³è”å…³ç³»ã€‚`,
                            'ç¡®è®¤åˆ é™¤',
                            {
                                confirmButtonText: 'ç¡®å®šåˆ é™¤',
                                cancelButtonText: 'å–æ¶ˆ',
                                type: 'warning',
                                confirmButtonClass: 'el-button--danger'
                            }
                        );

                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        const result = await api.delete_product_api(product.id);

                        if (result.success) {
                            ElMessage.success(result.message || 'å•†å“åˆ é™¤æˆåŠŸ');
                            loadProducts();
                        } else {
                            ElMessage.error(result.message || 'å•†å“åˆ é™¤å¤±è´¥');
                        }
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤å•†å“å¤±è´¥:', error);
                            ElMessage.error('å•†å“åˆ é™¤å¤±è´¥');
                        }
                    }
                };

                const handleSizeChange = (size) => {
                    pagination.pageSize = size;
                    pagination.page = 1;
                    loadProducts();
                };

                const handleCurrentChange = (page) => {
                    pagination.page = page;
                    loadProducts();
                };

                const formatDateTime = (dateTime) => {
                    if (!dateTime) return '-';
                    try {
                        const date = new Date(dateTime);
                        return date.toLocaleString('zh-CN', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    } catch (error) {
                        return dateTime;
                    }
                };

                const handleImageError = (event) => {
                    event.target.style.display = 'none';
                    const noImageDiv = document.createElement('div');
                    noImageDiv.className = 'no-cover';
                    noImageDiv.textContent = 'åŠ è½½å¤±è´¥';
                    event.target.parentNode.appendChild(noImageDiv);
                };

                const selectCoverImage = async () => {
                    try {
                        const api = getPywebviewApi();
                        if (!api) {
                            ElMessage.error('APIä¸å¯ç”¨');
                            return;
                        }

                        uploadingCover.value = true;

                        // é€‰æ‹©å›¾ç‰‡æ–‡ä»¶
                        const selectResult = await api.select_image_file();
                        if (!selectResult.success) {
                            if (selectResult.message !== 'æœªé€‰æ‹©æ–‡ä»¶') {
                                ElMessage.error(selectResult.message);
                            }
                            return;
                        }

                        // ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶
                        const uploadResult = await api.upload_image_file(
                            selectResult.file_path,
                            selectResult.filename
                        );

                        if (uploadResult.success) {
                            productForm.cover = uploadResult.path;

                            // ç«‹å³åŠ è½½å›¾ç‰‡é¢„è§ˆ
                            try {
                                const previewResult = await api.get_image_data_url(uploadResult.path);
                                if (previewResult.success) {
                                    coverPreviewUrl.value = previewResult.data_url;
                                }
                            } catch (error) {
                                console.error('åŠ è½½å›¾ç‰‡é¢„è§ˆå¤±è´¥:', error);
                            }

                            ElMessage.success('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ');
                        } else {
                            ElMessage.error(uploadResult.message || 'å›¾ç‰‡ä¸Šä¼ å¤±è´¥');
                        }

                    } catch (error) {
                        console.error('é€‰æ‹©å›¾ç‰‡å¤±è´¥:', error);
                        ElMessage.error('é€‰æ‹©å›¾ç‰‡å¤±è´¥');
                    } finally {
                        uploadingCover.value = false;
                    }
                };

                const loadProductImages = async () => {
                    const api = getPywebviewApi();
                    if (!api) return;

                    for (const product of productList.value) {
                        if (product.cover) {
                            try {
                                const result = await api.get_image_data_url(product.cover);
                                if (result.success) {
                                    // æ‰¾åˆ°å¯¹åº”çš„imgå…ƒç´ å¹¶è®¾ç½®src
                                    const imgElement = document.querySelector(`img[ref="cover-${product.id}"]`);
                                    if (imgElement) {
                                        imgElement.src = result.data_url;
                                        imgElement.style.display = 'block';
                                        // éšè—åŠ è½½æç¤º
                                        const loadingElement = imgElement.parentNode.querySelector('.loading-cover');
                                        if (loadingElement) {
                                            loadingElement.style.display = 'none';
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('åŠ è½½å•†å“å›¾ç‰‡å¤±è´¥:', error);
                            }
                        }
                    }
                };

                const getCoverImageUrl = async (imagePath) => {
                    if (!imagePath) return '';

                    // å¦‚æœæ˜¯ç½‘ç»œå›¾ç‰‡ï¼Œç›´æ¥è¿”å›
                    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                        return imagePath;
                    }

                    const api = getPywebviewApi();
                    if (!api) return '';

                    try {
                        // é€šè¿‡APIè·å–å›¾ç‰‡æ•°æ®URL
                        const result = await api.get_image_data_url(imagePath);
                        if (result.success) {
                            return result.data_url;
                        } else {
                            console.error('è·å–å›¾ç‰‡å¤±è´¥:', result.message);
                            return '';
                        }
                    } catch (error) {
                        console.error('è·å–å›¾ç‰‡å¤±è´¥:', error);
                        return '';
                    }
                };

                // å°é¢URLç¼“å­˜
                const coverUrlCache = new Map();

                const getTableImageUrl = async (imagePath) => {
                    if (!imagePath) return '';

                    // å¦‚æœæ˜¯ç½‘ç»œå›¾ç‰‡ï¼Œç›´æ¥è¿”å›
                    if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                        return imagePath;
                    }

                    // æ£€æŸ¥ç¼“å­˜
                    if (coverUrlCache.has(imagePath)) {
                        return coverUrlCache.get(imagePath);
                    }

                    // é€šè¿‡APIè·å–æ–‡ä»¶Blob
                    const api = getPywebviewApi();
                    if (!api) return '';

                    try {
                        const result = await api.get_image_blob(imagePath);
                        if (result.success && result.blob_data) {
                            // å°†base64è½¬æ¢ä¸ºBlob
                            const byteCharacters = atob(result.blob_data);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray], { type: result.mime_type || 'image/jpeg' });

                            // åˆ›å»ºObject URL
                            const objectUrl = URL.createObjectURL(blob);
                            coverUrlCache.set(imagePath, objectUrl);
                            return objectUrl;
                        }
                    } catch (error) {
                        console.error('è·å–å°é¢å¤±è´¥:', error);
                    }

                    return '';
                };

                const loadTableCovers = async () => {
                    console.log('ğŸ–¼ï¸ å¼€å§‹åŠ è½½è¡¨æ ¼å°é¢å›¾ç‰‡...');

                    for (const product of productList.value) {
                        if (product.cover && !product.coverObjectUrl) {
                            try {
                                const objectUrl = await getTableImageUrl(product.cover);
                                if (objectUrl) {
                                    product.coverObjectUrl = objectUrl;
                                }
                            } catch (error) {
                                console.error('åŠ è½½è¡¨æ ¼å°é¢å¤±è´¥:', product.cover, error);
                            }
                        }
                    }

                    console.log('âœ… è¡¨æ ¼å°é¢åŠ è½½å®Œæˆ');
                };

                const handleCoverImageError = (event) => {
                    handleImageError(event);
                };

                // ç”Ÿå‘½å‘¨æœŸ
                onMounted(() => {
                    console.log('ğŸš€ å•†å“ç®¡ç†é¡µé¢å·²æŒ‚è½½ï¼Œå¼€å§‹åŠ è½½æ•°æ®...');
                    console.log('ğŸ“Š å½“å‰productListçŠ¶æ€:', productList.value);
                    console.log('ğŸ“Š å½“å‰loadingçŠ¶æ€:', loading.value);

                    loadProducts();
                });

                return {
                    loading,
                    submitLoading,
                    uploadingCover,
                    productList,
                    dialogVisible,
                    isEdit,
                    productFormRef,
                    searchForm,
                    pagination,
                    productForm,
                    productRules,
                    dialogTitle,
                    loadProducts,
                    searchProducts,
                    refreshData,
                    showAddDialog,
                    editProduct,
                    resetForm,
                    submitProduct,
                    deleteProduct,
                    handleSizeChange,
                    handleCurrentChange,
                    formatDateTime,
                    handleImageError,
                    loadProductImages,
                    selectCoverImage,
                    getCoverImageUrl,
                    getTableImageUrl,
                    loadTableCovers,
                    editLoading,
                    handleCoverImageError,
                    coverPreviewUrl
                };
            }
        });

        // æ³¨å†Œæ‰€æœ‰å›¾æ ‡
        Object.keys(ElementPlusIconsVue).forEach(key => {
            app.component(key, ElementPlusIconsVue[key]);
        });

        // æ³¨å†ŒElement Pluså›¾æ ‡
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
            app.component(key, component);
        }

        app.use(ElementPlus).mount('#app');
    </script>
</body>

</html>
