# 交互文件
import time
import threading


# 核心库导入
try:
    import openpyxl
except ImportError as e:
    print(f"⚠️ openpyxl库导入失败: {e}")
    openpyxl = None

try:
    from sqlite3_util import (
        batch_insert, query_users, get_users_count, verify_insert_result,
        query_wechat_phrases, add_wechat_phrase, update_wechat_phrase, delete_wechat_phrase,
        add_user_log, query_user_logs
    )
except ImportError as e:
    print(f"⚠️ sqlite3_util模块导入失败: {e}")
    batch_insert = query_users = get_users_count = verify_insert_result = None
    query_wechat_phrases = add_wechat_phrase = update_wechat_phrase = delete_wechat_phrase = None
    add_user_log = query_user_logs = None

# 微信自动化导入
try:
    from wechat_automation import WeChatAutomation
    WECHAT_AUTOMATION_AVAILABLE = True
except ImportError as e:
    print(f"⚠️ 微信自动化模块导入失败: {e}")
    WeChatAutomation = None
    WECHAT_AUTOMATION_AVAILABLE = False

# 全局控制台输出变量
GLOBAL_CONSOLE_OUTPUT = {
    "logs": [],  # 控制台日志列表
    "is_processing": False,  # 是否正在处理
    "current_status": "idle",  # 当前状态: idle, processing, completed, error
    "current_message": "",  # 当前状态消息
    "progress": 0,  # 进度百分比 0-100
    "last_update": time.time()
}

# 全局取消标志
PROCESSING_CANCELLED = False

# 线程锁
console_lock = threading.Lock()

def add_console_log(message, log_type="info"):
    """添加控制台日志"""
    global GLOBAL_CONSOLE_OUTPUT

    with console_lock:
        log_entry = {
            "timestamp": time.time(),
            "time_str": time.strftime("%H:%M:%S", time.localtime()),
            "message": message,
            "type": log_type  # info, success, warning, error
        }

        GLOBAL_CONSOLE_OUTPUT["logs"].append(log_entry)

        # 限制日志数量，只保留最新50条
        if len(GLOBAL_CONSOLE_OUTPUT["logs"]) > 50:
            GLOBAL_CONSOLE_OUTPUT["logs"] = GLOBAL_CONSOLE_OUTPUT["logs"][-50:]

        GLOBAL_CONSOLE_OUTPUT["last_update"] = time.time()

        # 同时打印到控制台
        print(f"[{log_entry['time_str']}] {message}")

def update_console_status(status="idle", message="", progress=0, is_processing=False):
    """更新控制台状态"""
    global GLOBAL_CONSOLE_OUTPUT

    with console_lock:
        GLOBAL_CONSOLE_OUTPUT["current_status"] = status
        GLOBAL_CONSOLE_OUTPUT["current_message"] = message
        GLOBAL_CONSOLE_OUTPUT["progress"] = progress
        GLOBAL_CONSOLE_OUTPUT["is_processing"] = is_processing
        GLOBAL_CONSOLE_OUTPUT["last_update"] = time.time()

def get_console_output():
    """获取控制台输出"""
    global GLOBAL_CONSOLE_OUTPUT

    with console_lock:
        return GLOBAL_CONSOLE_OUTPUT.copy()

def reset_console_output():
    """重置控制台输出"""
    global GLOBAL_CONSOLE_OUTPUT

    with console_lock:
        GLOBAL_CONSOLE_OUTPUT["logs"] = []
        GLOBAL_CONSOLE_OUTPUT["is_processing"] = False
        GLOBAL_CONSOLE_OUTPUT["current_status"] = "idle"
        GLOBAL_CONSOLE_OUTPUT["current_message"] = ""
        GLOBAL_CONSOLE_OUTPUT["progress"] = 0
        GLOBAL_CONSOLE_OUTPUT["last_update"] = time.time()

def cancel_processing():
    """取消当前处理"""
    global PROCESSING_CANCELLED
    PROCESSING_CANCELLED = True
    add_console_log("🛑 用户取消处理", "warning")
    update_console_status(status="cancelled", message="处理已取消", is_processing=False)

    # 返回取消结果，但这里无法获取已处理数据，需要在process_excel_file中处理
    return {
        "success": True,
        "message": "处理已取消",
        "cancelled": True
    }

def is_processing_cancelled():
    """检查是否已取消处理"""
    return PROCESSING_CANCELLED

def reset_cancel_flag():
    """重置取消标志"""
    global PROCESSING_CANCELLED
    PROCESSING_CANCELLED = False

def check_api_response_valid(real_data):
    """检查API响应是否有效，判断是否被风控"""
    if not real_data:
        return False, "API返回空数据"

    if not isinstance(real_data, dict):
        return False, "API返回数据格式错误"

    # 检查关键字段 - 只检查unique_id，signature可以为空
    if not real_data.get('unique_id'):
        return False, "API返回数据不完整，可能被风控或登录失效"

    return True, "数据有效"

class API:
    def __init__(self):
        # 导入redislite和数据库工具
        try:
            from redislite import get_log_manager
            from sqlite3_util import add_user_log, query_user_logs, clear_user_logs, check_user_added
            self.log_manager = get_log_manager()
            self.add_user_log = add_user_log
            self.query_user_logs = query_user_logs
            self.clear_user_logs = clear_user_logs
            self.check_user_added = check_user_added
        except ImportError as e:
            print(f"导入redislite或数据库工具失败: {e}")
            self.log_manager = None

    def get_console_output(self):
        """获取控制台输出"""
        return get_console_output()

    def stop_processing(self, params=None):
        """终止当前处理"""
        global PROCESSING_CANCELLED
        PROCESSING_CANCELLED = True
        add_console_log("🛑 用户请求终止操作", "warning")
        return {
            "success": True,
            "message": "终止请求已发送"
        }

    def reset_console_output(self):
        """重置控制台输出"""
        return reset_console_output()

    def cancel_processing(self):
        """取消当前处理"""
        return cancel_processing()

    def check_token_status(self):
        """检查token状态"""
        try:
            from cmm import get_latest_token
            token = get_latest_token()

            if token:
                return {
                    "success": True,
                    "has_token": True,
                    "token_preview": f"{token[:20]}...",
                    "message": "Token可用"
                }
            else:
                return {
                    "success": True,
                    "has_token": False,
                    "message": "未找到有效Token"
                }
        except Exception as e:
            return {
                "success": False,
                "has_token": False,
                "message": f"检查Token失败: {str(e)}"
            }



    def get_users_data(self, page=1, page_size=200, search_params=None):
        """
        获取用户数据（分页+搜索）
        """
        try:
            print(f"=== 查询用户数据 ===")
            print(f"页码: {page}, 每页: {page_size}")
            if search_params:
                print(f"搜索条件: {search_params}")

            # 首先检查数据库和表是否存在
            import os
            db_path = 'system.db'
            if not os.path.exists(db_path):
                print(f"❌ 数据库文件不存在: {db_path}")
                return {
                    "success": False,
                    "message": "数据库文件不存在，请先上传Excel文件",
                    "data": [],
                    "total": 0
                }

            # 检查表是否存在
            conn = __import__('sqlite3').connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='users'")
            table_exists = cursor.fetchone() is not None

            if not table_exists:
                conn.close()
                print(f"❌ users表不存在")
                return {
                    "success": False,
                    "message": "users表不存在，请先上传Excel文件",
                    "data": [],
                    "total": 0
                }

            # 检查表中是否有数据
            cursor.execute("SELECT COUNT(*) FROM users")
            total_records = cursor.fetchone()[0]
            print(f"📊 数据库中总记录数: {total_records}")
            conn.close()

            # 构建搜索条件
            where_conditions = []
            params = []

            if search_params:
                if search_params.get('fileName'):
                    where_conditions.append("file_name LIKE ?")
                    params.append(f"%{search_params['fileName']}%")

                if search_params.get('description'):
                    where_conditions.append("intro LIKE ?")
                    params.append(f"%{search_params['description']}%")

                if search_params.get('phone'):
                    # 这里假设phone字段存在，如果没有可以搜索unique_id
                    where_conditions.append("unique_id LIKE ?")
                    params.append(f"%{search_params['phone']}%")

                if search_params.get('wechat'):
                    # 这里假设wechat字段存在，如果没有可以搜索username
                    where_conditions.append("username LIKE ?")
                    params.append(f"%{search_params['wechat']}%")

            # 构建WHERE子句
            where_clause = ""
            if where_conditions:
                where_clause = "WHERE " + " AND ".join(where_conditions)

            # 查询总记录数
            conn = __import__('sqlite3').connect('system.db')
            conn.row_factory = __import__('sqlite3').Row
            cursor = conn.cursor()

            count_sql = f"SELECT COUNT(*) FROM users {where_clause}"
            cursor.execute(count_sql, params)
            total_count = cursor.fetchone()[0]
            print(f"符合条件的总记录数: {total_count}")

            # 计算偏移量
            offset = (page - 1) * page_size

            # 查询数据
            data_sql = f"""
                SELECT * FROM users
                {where_clause}
                ORDER BY create_time DESC
                LIMIT ? OFFSET ?
            """

            cursor.execute(data_sql, params + [page_size, offset])
            results = [dict(row) for row in cursor.fetchall()]
            conn.close()

            add_console_log(f"📊 查询到 {len(results)} 条记录", "info")
            for i, record in enumerate(results[:3], 1):
                add_console_log(f"  {i}. {record.get('username')} - {record.get('cmm_id')}", "info")

            return {
                "success": True,
                "data": results,
                "total": total_count,
                "page": page,
                "page_size": page_size,
                "total_pages": (total_count + page_size - 1) // page_size,
                "search_params": search_params
            }

        except Exception as e:
            print(f"查询用户数据失败: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"查询失败: {str(e)}",
                "data": [],
                "total": 0
            }

    # 处理文件内容
    def process_file(self, file_data):
        """
        处理前端传来的文件数据，直接在内存中读取Excel内容
        :param file_data: 包含文件信息和内容的字典
        :return: 处理结果
        """
        # 检查必要的库
        if openpyxl is None:
            return {
                "success": False,
                "message": "openpyxl库未安装，无法处理Excel文件"
            }

        try:
            # 重置取消标志
            reset_cancel_flag()

            # 更新状态：开始处理
            update_console_status(status="processing", message="开始处理Excel文件...", is_processing=True)
            add_console_log("🚀 开始处理Excel文件...", "info")

            if not file_data:
                add_console_log("❌ 未接收到文件数据", "error")
                update_console_status(status="error", message="未接收到文件数据", is_processing=False)
                return {
                    "success": False,
                    "message": "未接收到文件数据"
                }

            # 检查必要字段
            required_fields = ['name', 'content']
            for field in required_fields:
                if field not in file_data:
                    add_console_log(f"❌ 缺少必要字段: {field}", "error")
                    update_console_status(status="error", message=f"缺少必要字段: {field}", is_processing=False)
                    return {
                        "success": False,
                        "message": f"缺少必要字段: {field}"
                    }

            add_console_log(f"📄 读取文件: {file_data['name']}", "info")
            add_console_log(f"📊 文件大小: {file_data.get('size', 'unknown')} bytes", "info")

            # 将字节数组转换为字节对象
            file_content = bytes(file_data['content'])
            print(f"转换后的字节长度: {len(file_content)}")

            # 使用BytesIO在内存中创建文件对象
            from io import BytesIO
            # 文件
            file_stream = BytesIO(file_content)

            # 使用openpyxl直接从内存读取Excel文件
            add_console_log("📊 开始解析Excel文件结构", "info")
            update_console_status(status="processing", message="正在解析Excel文件...", progress=10)
            workbook = openpyxl.load_workbook(file_stream)

            # 获取工作表信息
            sheet_names = workbook.sheetnames
            add_console_log(f"📋 发现 {len(sheet_names)} 个工作表", "success")

            # 读取第一个工作表
            sheet = workbook.active
            add_console_log(f"📄 当前工作表: {sheet.title} ({sheet.max_row}行 x {sheet.max_column}列)", "info")

            # 读取表头（第一行）
            headers = []
            for col in range(1, sheet.max_column + 1):
                cell_value = sheet.cell(row=1, column=col).value
                headers.append(str(cell_value) if cell_value else f"列{col}")

            add_console_log(f"📝 表头: {', '.join(headers[:5])}{'...' if len(headers) > 5 else ''}", "info")

            # 读取所有数据，包括超链接
            add_console_log("🔍 开始扫描数据和超链接", "info")
            update_console_status(status="processing", message="正在扫描数据和超链接...", progress=20)
            all_data = []
            hyperlinks_found = []

            for row in range(2, sheet.max_row + 1):  # 从第2行开始
                row_data = []
                row_hyperlinks = []

                for col in range(1, sheet.max_column + 1):
                    cell = sheet.cell(row=row, column=col)
                    cell_value = str(cell.value) if cell.value else ""
                    row_data.append(cell_value)

                    # 检查是否有超链接
                    if cell.hyperlink:
                        hyperlink_info = {
                            'row': row,
                            'col': col,
                            'column_name': headers[col-1] if col-1 < len(headers) else f"列{col}",
                            'cell_value': cell_value,
                            'hyperlink': cell.hyperlink.target if cell.hyperlink.target else str(cell.hyperlink)
                        }
                        row_hyperlinks.append(hyperlink_info)
                        hyperlinks_found.append(hyperlink_info)
                        print(f"发现超链接 - 行{row}列{col}({headers[col-1] if col-1 < len(headers) else f'列{col}'}): {cell_value} -> {hyperlink_info['hyperlink']}")

                all_data.append(row_data)

                # 只打印前5行作为示例
                if row <= 6:
                    print(f"第{row}行: {row_data}")
                    if row_hyperlinks:
                        for link in row_hyperlinks:
                            print(f"  └─ 超链接: {link['cell_value']} -> {link['hyperlink']}")

            add_console_log(f"✅ 数据扫描完成！发现 {len(hyperlinks_found)} 个超链接", "success")
            update_console_status(status="processing", message=f"发现 {len(hyperlinks_found)} 个超链接", progress=40)

            # 处理超链接
            if hyperlinks_found:
                add_console_log(f"🔗 开始处理 {len(hyperlinks_found)} 个超链接", "info")

                # 提取ID并组装SQLite数据
                import re
                from datetime import datetime

                sqlite_data = []
                extracted_ids = []
                insert_success = False
                insert_message = "未执行数据库插入"

                # 获取爬取配置
                crawl_config = file_data.get('crawlConfig', {})
                sleep_interval = crawl_config.get('sleepInterval', 3)  # 默认3秒
                add_console_log(f"⚙️ 爬取配置 - 休眠间隔: {sleep_interval}秒", "info")

                # 先提取所有ID
                add_console_log("🔍 正在提取所有蝉妈妈ID...", "info")
                all_extracted_ids = []
                for link in hyperlinks_found:
                    url = link['hyperlink']
                    match = re.search(r'authorDetail/([^/?]+)', url)
                    if match:
                        author_id = match.group(1)
                        all_extracted_ids.append(author_id)

                add_console_log(f"📊 从Excel中提取到 {len(all_extracted_ids)} 个ID", "info")

                # 检查哪些ID已经存在于数据库中
                add_console_log("🔍 检查数据库中已存在的ID...", "info")
                from sqlite3_util import check_existing_ids_in_users
                id_check_result = check_existing_ids_in_users('system.db', file_data['name'], all_extracted_ids)

                existing_count = id_check_result['existing_count']
                new_count = id_check_result['new_count']
                new_ids = id_check_result['new_ids']

                if existing_count > 0:
                    add_console_log(f"⚠️ 发现 {existing_count} 个ID已存在于数据库中，将跳过", "warning")
                    add_console_log(f"✅ 需要处理 {new_count} 个新ID", "info")
                else:
                    add_console_log(f"✅ 所有 {new_count} 个ID都是新的，需要全部处理", "info")

                # 如果没有新ID需要处理
                if new_count == 0:
                    add_console_log("✅ 所有ID都已存在于数据库中，无需重复处理", "success")
                    update_console_status(status="completed", message="所有数据已存在，无需重复处理", progress=100, is_processing=False)
                    return {
                        "success": True,
                        "message": "所有数据已存在于数据库中，无需重复处理",
                        "data": {
                            "filename": file_data['name'],
                            "total_ids": len(all_extracted_ids),
                            "existing_ids": existing_count,
                            "new_ids": 0,
                            "skipped": True
                        }
                    }

                # 获取最新token用于API调用
                add_console_log("🔑 获取最新token...", "info")
                token = self.get_latest_token_from_db()
                if not token:
                    add_console_log("❌ 未找到有效token，无法处理Excel文件", "error")
                    update_console_status(status="error", message="未找到有效token，请先登录蝉妈妈", is_processing=False)
                    return {
                        "success": False,
                        "message": "未找到有效token，请先登录蝉妈妈账号",
                        "data": None
                    }
                else:
                    add_console_log(f"✅ 获取到token: {token[:20]}...", "success")

                import time

                # 只处理新的ID，过滤掉已存在的
                new_hyperlinks = []
                for link in hyperlinks_found:
                    url = link['hyperlink']
                    match = re.search(r'authorDetail/([^/?]+)', url)
                    if match:
                        author_id = match.group(1)
                        if author_id in new_ids:  # 只处理新的ID
                            new_hyperlinks.append(link)

                add_console_log(f"📋 实际需要处理的超链接: {len(new_hyperlinks)} 个", "info")

                # 分批处理，每批返回进度
                batch_size = 5  # 每5个为一批
                total_count = len(new_hyperlinks)
                processed_count = 0

                # 获取爬取配置
                from cmm import get_crawl_config
                crawl_config = get_crawl_config()

                for i, link in enumerate(new_hyperlinks, 1):
                    # 检查是否取消处理
                    if is_processing_cancelled():
                        add_console_log("🛑 处理已被用户取消", "warning")

                        # 取消时也使用直连IP进行一次请求
                        add_console_log("🌐 取消处理时使用直连IP记录最后请求", "info")

                        # 更新状态为正在进行直连请求
                        update_console_status(status="processing", message="取消处理中，正在进行最后的直连请求...", is_processing=True)

                        try:
                            from cmm import make_direct_request
                            test_id = 'Te4oLu6PzddK8v0S_JURlE20CMuhagMW'  # 使用测试ID
                            make_direct_request(test_id, token)
                            add_console_log("✅ 直连请求完成，准备停止处理", "info")
                        except Exception as e:
                            add_console_log(f"⚠️ 取消时直连请求失败: {e}", "warning")

                        # 直连请求完成后，检查是否有已处理的数据并立即return
                        if len(sqlite_data) > 0:
                            add_console_log(f"📊 已处理 {len(sqlite_data)} 条数据", "info")

                            update_console_status(status="cancelled", message="处理已取消，询问是否保存已处理数据", is_processing=False)
                            return {
                                "success": False,
                                "message": "处理已取消",
                                "cancelled": True,
                                "has_processed_data": True,
                                "processed_count": len(sqlite_data),
                                "processed_data": sqlite_data,
                                "ask_save": True  # 标记需要询问用户是否保存
                            }
                        else:
                            update_console_status(status="cancelled", message="处理已取消", is_processing=False)
                            return {
                                "success": False,
                                "message": "处理已取消",
                                "cancelled": True,
                                "has_processed_data": False
                            }

                    # 休眠控制 - 只在非代理模式下使用
                    if not crawl_config['proxy_enabled']:
                        # 单个数据爬取前的休眠
                        if crawl_config['wait_time'] > 0:
                            add_console_log(f"⏰ 直连模式单个数据休眠 {crawl_config['wait_time']} 秒", "info")
                            time.sleep(crawl_config['wait_time'])

                        # 检查是否需要大休眠
                        if processed_count > 0 and processed_count % crawl_config['count_wait'] == 0:
                            add_console_log(f"😴 直连模式已处理 {processed_count} 条数据，大休眠 {crawl_config['count_wait_time']} 秒", "info")
                            time.sleep(crawl_config['count_wait_time'])
                    else:
                        # 代理模式下不使用休眠
                        add_console_log(f"🚀 代理模式：无休眠，直接处理第 {i} 条数据", "info")

                    # 更新进度
                    progress = 40 + (i / len(new_hyperlinks)) * 50  # 40-90%
                    update_console_status(status="processing", message=f"正在获取第 {i}/{len(new_hyperlinks)} 个达人信息", progress=progress)

                    # 提取authorDetail/后面的ID
                    url = link['hyperlink']
                    match = re.search(r'authorDetail/([^/?]+)', url)
                    if match:
                        author_id = match.group(1)
                        extracted_ids.append(author_id)

                        add_console_log(f"📡 [{i}/{len(new_hyperlinks)}] 获取达人: {link['cell_value']} ({author_id})", "info")

                        # 调用get_real_info获取真实数据
                        real_intro = ""
                        real_unique_id = ""
                        real_code = ""

                        # 使用token调用API获取真实数据
                        try:
                            from cmm import get_real_info, extract_contact_code
                            # 正常请求不使用直连IP
                            real_data = get_real_info(author_id, token, use_direct_at_end=False)

                            # 检查API响应是否有效（风控检测）
                            is_valid, error_msg = check_api_response_valid(real_data)

                            if is_valid:
                                real_intro = real_data['signature']
                                real_unique_id = real_data['unique_id']

                                # 从signature中提取联系方式
                                real_code = extract_contact_code(real_intro)

                                add_console_log(f"✅ 获取成功: {link['cell_value']} | 抖音ID: {real_unique_id}", "success")
                                if real_code:
                                    add_console_log(f"📞 提取联系方式: {real_code}", "success")
                                else:
                                    add_console_log("📞 未提取到联系方式", "warning")
                            else:
                                # 检测到风控，询问用户是否保存已处理的数据
                                add_console_log(f"❌ {error_msg}", "error")
                                add_console_log(f"🚨 检测到风控！已成功处理 {processed_count} 条数据", "warning")

                                # 获取服务器返回的消息
                                server_message = real_data.get('server_message', error_msg)
                                if server_message:
                                    add_console_log(f"📡 服务器消息: {server_message}", "warning")

                                # 删除数据库中的token
                                try:
                                    import sqlite3
                                    conn = sqlite3.connect('system.db')
                                    cursor = conn.cursor()
                                    cursor.execute("DELETE FROM tokens")
                                    conn.commit()
                                    deleted_count = cursor.rowcount
                                    conn.close()
                                    add_console_log(f"🗑️ 已清除 {deleted_count} 个失效token", "warning")
                                except Exception as token_error:
                                    add_console_log(f"❌ 清除token失败: {str(token_error)}", "error")

                                # 返回风控信息，让前端询问用户是否保存
                                update_console_status(status="risk_control", message=f"触发风控，已处理{processed_count}条", is_processing=False)
                                return {
                                    "success": False,
                                    "message": f"检测到风控: {error_msg}",
                                    "risk_control": True,
                                    "server_message": server_message,  # 服务器返回的消息
                                    "token_cleared": True,
                                    "processed_count": processed_count,
                                    "total_count": total_count,
                                    "processed_data": sqlite_data,
                                    "ask_save_confirmation": True
                                }

                        except Exception as e:
                            add_console_log(f"❌ API调用失败: {str(e)[:50]}...", "error")

                        data_row = {
                            'file_name': file_data['name'],
                            'username': link['cell_value'],
                            'intro': real_intro,
                            'unique_id': real_unique_id,
                            'cmm_id': author_id,
                            'code': real_code,
                            'create_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        }

                        sqlite_data.append(data_row)
                        processed_count += 1

                        add_console_log(f"✅ 完成第 {i} 个达人信息获取: {link['cell_value']}", "success")

                        # 添加休眠间隔，避免请求过快
                        if i < len(new_hyperlinks):  # 最后一个不需要休眠
                            add_console_log(f"⏱️ 休眠 {sleep_interval} 秒，避免请求过快", "warning")
                            time.sleep(sleep_interval)

                add_console_log(f"📊 提取到 {len(extracted_ids)} 个ID", "info")

                # 生成批量插入SQL
                if sqlite_data:
                    add_console_log("💾 开始准备数据库插入", "info")
                    print("-- users 表结构")
                    print("CREATE TABLE IF NOT EXISTS users (")
                    print("    id INTEGER PRIMARY KEY AUTOINCREMENT,")
                    print("    file_name TEXT NOT NULL,  -- 原始文件名")
                    print("    username TEXT NOT NULL,   -- 用户昵称")
                    print("    intro TEXT,               -- 简介信息")
                    print("    unique_id TEXT,           -- 抖音ID")
                    print("    cmm_id TEXT,              -- 蝉妈妈ID")
                    print("    create_time TEXT NOT NULL -- 创建时间")
                    print(");")
                    print()

                    # 批量插入语句
                    print("-- 批量插入数据")
                    print("INSERT INTO users (file_name, username, intro, unique_id, cmm_id, code, create_time) VALUES")
                    values_list = []
                    for data in sqlite_data:
                        values = f"('{data['file_name']}', '{data['username']}', '{data['intro']}', '{data['unique_id']}', '{data['cmm_id']}', '{data['code']}', '{data['create_time']}')"
                        values_list.append(values)

                    print(",\n".join(values_list) + ";")

                    print(f"\n总共 {len(sqlite_data)} 条数据准备插入到 users 表")

                    # 详细数据预览
                    print(f"\n=== 数据详情预览 ===")
                    for i, data in enumerate(sqlite_data[:5], 1):  # 只显示前5条
                        print(f"{i}. 文件: {data['file_name']}")
                        print(f"   用户: {data['username']}")
                        print(f"   简介: {data['intro'][:50]}...")
                        print(f"   抖音ID: {data['unique_id']}")
                        print(f"   蝉妈妈ID: {data['cmm_id']}")
                        print(f"   联系方式: {data['code'] if data['code'] else '未提取'}")
                        print(f"   时间: {data['create_time']}")
                        print()

                    if len(sqlite_data) > 5:
                        print(f"... 还有 {len(sqlite_data) - 5} 条数据")

                    # 插入数据到数据库
                    print(f"\n=== 开始插入数据到数据库 ===")
                    try:
                        # 准备插入数据
                        field_names = ['file_name', 'username', 'intro', 'unique_id', 'cmm_id', 'code', 'create_time']
                        insert_data = []

                        for data in sqlite_data:
                            row_tuple = (
                                data['file_name'],
                                data['username'],
                                data['intro'],
                                data['unique_id'],
                                data['cmm_id'],
                                data['code'],
                                data['create_time']
                            )
                            insert_data.append(row_tuple)

                        print(f"准备插入 {len(insert_data)} 条数据到 users 表...")

                        # 执行批量插入
                        inserted_count = batch_insert(
                            db_path='system.db',
                            table_name='users',
                            field_names=field_names,
                            data=insert_data,
                            batch_size=50
                        )

                        if inserted_count > 0:
                            add_console_log(f"✅ 成功插入 {inserted_count} 条数据到数据库", "success")

                            # 验证插入结果
                            verify_result = verify_insert_result()
                            add_console_log(f"📊 数据库总记录数: {verify_result.get('record_count', 0)}", "info")

                            if verify_result.get('latest_records'):
                                print(f"最新5条记录:")
                                for i, record in enumerate(verify_result['latest_records'][:3], 1):
                                    print(f"  {i}. ID:{record.get('id')} 用户:{record.get('username')} 蝉妈妈ID:{record.get('cmm_id')}")

                            insert_success = True
                            insert_message = f"成功插入 {inserted_count} 条数据到数据库，当前总记录数: {verify_result.get('record_count', 0)}"
                        else:
                            add_console_log("❌ 数据插入失败", "error")
                            insert_success = False
                            insert_message = "数据插入失败"

                    except Exception as insert_error:
                        add_console_log(f"❌ 数据库插入异常: {str(insert_error)}", "error")
                        import traceback
                        traceback.print_exc()
                        insert_success = False
                        insert_message = f"数据库插入异常: {str(insert_error)}"

            else:
                add_console_log("⚠️ 未发现任何超链接", "warning")

            # 关闭工作簿
            workbook.close()

            print("=" * 50)
            print("Excel文件读取完成！")

            # 准备返回数据
            return_data = {
                "filename": file_data['name'],
                "sheet_names": sheet_names,
                "current_sheet": sheet.title,
                "max_row": sheet.max_row,
                "max_column": sheet.max_column,
                "headers": headers,
                "sample_data": all_data[:5],  # 前5行作为示例
                "total_rows": len(all_data),
                "hyperlinks_count": len(hyperlinks_found),
                "hyperlinks": hyperlinks_found
            }

            # 如果有超链接，添加提取的ID和SQLite数据
            if hyperlinks_found and 'extracted_ids' in locals():
                return_data.update({
                    "extracted_ids": extracted_ids,
                    "sqlite_data": sqlite_data,
                    "sqlite_ready_count": len(sqlite_data),
                    "db_insert_success": insert_success,
                    "db_insert_message": insert_message
                })

            # 处理完成，使用直连IP进行最后一次请求
            add_console_log("🎉 Excel文件处理完成！所有达人信息已获取", "success")
            add_console_log("🌐 处理完成时使用直连IP记录最后请求", "info")

            # 更新状态为正在进行最后的直连请求
            update_console_status(status="processing", message="正在进行最后的直连请求...", progress=95, is_processing=True)

            try:
                from cmm import make_direct_request
                test_id = 'Te4oLu6PzddK8v0S_JURlE20CMuhagMW'  # 使用测试ID
                make_direct_request(test_id, token)
                add_console_log("✅ 直连请求完成", "success")
            except Exception as e:
                add_console_log(f"⚠️ 完成时直连请求失败: {e}", "warning")

            # 直连请求完成后才设置为完成状态
            update_console_status(status="completed", message="Excel文件处理完成！", progress=100, is_processing=False)

            # 延迟3秒后重置控制台，让用户看到完成信息
            import threading
            def delayed_reset():
                import time
                time.sleep(3)
                reset_console_output()
                add_console_log("📋 控制台已重置，可以处理新文件", "info")

            threading.Thread(target=delayed_reset, daemon=True).start()

            return {
                "success": True,
                "message": "Excel文件读取成功",
                "data": return_data
            }

        except Exception as e:
            add_console_log(f"❌ 处理失败: {str(e)}", "error")

            # 处理失败时也使用直连IP进行一次请求
            add_console_log("🌐 处理失败时使用直连IP记录最后请求", "info")

            # 更新状态为正在进行最后的直连请求
            update_console_status(status="processing", message="处理失败，正在进行最后的直连请求...", is_processing=True)

            try:
                from cmm import make_direct_request
                # 尝试获取token，如果没有就使用空token
                token = self.get_latest_token_from_db() or ''
                test_id = 'Te4oLu6PzddK8v0S_JURlE20CMuhagMW'  # 使用测试ID
                make_direct_request(test_id, token)
                add_console_log("✅ 直连请求完成", "success")
            except Exception as direct_error:
                add_console_log(f"⚠️ 失败时直连请求失败: {direct_error}", "warning")

            # 直连请求完成后才设置为错误状态
            update_console_status(status="error", message=f"处理失败: {str(e)}", is_processing=False)
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Excel文件处理失败: {str(e)}",
                "error": str(e)
            }

    def api_login_cmm(self, username, password):
        """
        蝉妈妈登录API接口（自动检测代理）
        """
        try:
            print(f"=== 蝉妈妈登录 ===")
            print(f"用户名: {username}")
            print(f"自动检测代理模式")

            # 验证输入
            if not username or not password:
                return {
                    "success": False,
                    "message": "用户名和密码不能为空",
                    "logged_in": False,
                    "token": ''
                }

            # 调用cmm.py的登录方法（自动检测代理）
            from cmm import login_cmm
            result = login_cmm(username, password)
            print(f"登录结果: {result}")
            if result and result.get('data', {}).get('logged_in'):
                print("✅ 蝉妈妈登录成功")

                return {
                    "success": True,
                    "message": "登录成功",
                    "data": result.get('data', {}),
                    "logged_in": result.get('data', {}).get('logged_in', False),
                    "token": result.get('data', {}).get('token', '')
                }
            else:
                print(f"❌ 蝉妈妈登录失败")
                error_msg = "登录失败，请检查用户名和密码"
                if result and result.get('message'):
                    error_msg = result.get('message')

                return {
                    "success": False,
                    "message": error_msg,
                    "data": result,
                    "logged_in": False,
                    "token": ''
                }

        except Exception as e:
            print(f"❌ 蝉妈妈登录异常: {str(e)}")
            return {
                "success": False,
                "message": f"登录异常: {str(e)}",
                "logged_in": False,
                "token": ''
            }

    def get_latest_token_from_db(self):
        """
        从数据库获取最新token
        """
        try:
            import sqlite3
            conn = sqlite3.connect('system.db')
            cursor = conn.cursor()

            cursor.execute("""
                SELECT token FROM tokens
                ORDER BY create_time DESC
                LIMIT 1
            """)
            result = cursor.fetchone()
            conn.close()

            if result:
                return result[0]
            else:
                return None
        except Exception as e:
            print(f"❌ 从数据库获取token失败: {str(e)}")
            return None

    def get_processing_status(self):
        """
        获取处理状态（用于前端显示进度）
        """
        import time
        return {
            "status": "ready",
            "message": "系统就绪",
            "timestamp": time.time()
        }

    def update_processing_progress(self, current=None, total=None, message=""):
        """
        更新处理进度并返回全局控制台输出
        """
        # 如果传入了参数，更新全局状态
        if current is not None and total is not None:
            progress_percent = round((current / total) * 100, 1) if total > 0 else 0
            update_console_status(
                status="processing",
                message=message,
                progress=progress_percent,
                is_processing=True
            )
            print('更新被调用····')
        # 返回全局控制台输出
        return get_console_output()

    def save_export_file(self, file_content, file_name, file_type='csv'):
        """
        保存导出文件到用户指定位置（使用pywebview文件对话框）
        """
        import os

        try:
            print(f"=== 保存导出文件 ===")
            print(f"文件名: {file_name}")
            print(f"文件类型: {file_type}")
            print(f"内容长度: {len(file_content)} 字符")

            # 尝试使用pywebview的文件对话框
            try:
                import webview

                # 设置文件类型过滤器
                if file_type.lower() == 'csv':
                    file_types = ('CSV文件 (*.csv)', '*.csv')
                elif file_type.lower() == 'xlsx':
                    file_types = ('Excel文件 (*.xlsx)', '*.xlsx')
                else:
                    file_types = ('所有文件 (*.*)', '*.*')

                # 使用pywebview的保存文件对话框
                file_path = webview.windows[0].create_file_dialog(
                    webview.SAVE_DIALOG,
                    directory=os.path.expanduser('~/Downloads'),  # 默认下载文件夹
                    save_filename=file_name,
                    file_types=(file_types,)
                )

                if not file_path:
                    print("用户取消了文件保存")
                    return {
                        "success": False,
                        "message": "用户取消了文件保存"
                    }

                # file_path可能是列表，取第一个
                if isinstance(file_path, (list, tuple)):
                    file_path = file_path[0] if file_path else None

                if not file_path:
                    return {
                        "success": False,
                        "message": "未选择保存路径"
                    }

                print(f"保存路径: {file_path}")

            except Exception as webview_error:
                print(f"⚠️ pywebview文件对话框失败: {str(webview_error)}")

                # 备用方案：直接保存到下载文件夹
                downloads_dir = os.path.expanduser('~/Downloads')
                if not os.path.exists(downloads_dir):
                    downloads_dir = os.path.expanduser('~')  # 用户主目录

                file_path = os.path.join(downloads_dir, file_name)
                print(f"使用默认路径: {file_path}")

            # 保存文件
            if file_type.lower() == 'csv':
                # CSV文件需要UTF-8编码和BOM
                with open(file_path, 'w', encoding='utf-8-sig', newline='') as f:
                    f.write(file_content)
            else:
                # 其他文件类型
                with open(file_path, 'w', encoding='utf-8', newline='') as f:
                    f.write(file_content)

            # 验证文件是否保存成功
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                print(f"✅ 文件保存成功")
                print(f"   路径: {file_path}")
                print(f"   大小: {file_size} 字节")

                return {
                    "success": True,
                    "message": f"文件已保存到: {file_path}",
                    "file_path": file_path,
                    "file_size": file_size
                }
            else:
                print(f"❌ 文件保存失败")
                return {
                    "success": False,
                    "message": "文件保存失败"
                }

        except Exception as e:
            print(f"❌ 保存文件异常: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"保存文件失败: {str(e)}"
            }

    def save_to_downloads(self, file_content, file_name, file_type='csv'):
        """
        直接保存文件到Downloads文件夹（最简单的方案）
        """
        import os

        try:
            print(f"=== 直接保存到Downloads文件夹 ===")
            print(f"文件名: {file_name}")
            print(f"文件类型: {file_type}")
            print(f"内容长度: {len(file_content)} 字符")

            # 获取Downloads文件夹路径
            downloads_dir = os.path.expanduser('~/Downloads')
            if not os.path.exists(downloads_dir):
                # 如果Downloads文件夹不存在，使用用户主目录
                downloads_dir = os.path.expanduser('~')
                print(f"Downloads文件夹不存在，使用主目录: {downloads_dir}")

            # 构建完整文件路径
            file_path = os.path.join(downloads_dir, file_name)

            # 如果文件已存在，添加序号
            base_name, ext = os.path.splitext(file_path)
            counter = 1
            while os.path.exists(file_path):
                file_path = f"{base_name}_{counter}{ext}"
                counter += 1

            print(f"保存路径: {file_path}")

            # 保存文件
            if file_type.lower() == 'csv':
                # CSV文件需要UTF-8编码和BOM
                with open(file_path, 'w', encoding='utf-8-sig', newline='') as f:
                    f.write(file_content)
            else:
                # 其他文件类型
                with open(file_path, 'w', encoding='utf-8', newline='') as f:
                    f.write(file_content)

            # 验证文件是否保存成功
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                print(f"✅ 文件保存成功")
                print(f"   路径: {file_path}")
                print(f"   大小: {file_size} 字节")

                return {
                    "success": True,
                    "message": f"文件已保存到Downloads文件夹: {os.path.basename(file_path)}",
                    "file_path": file_path,
                    "file_size": file_size
                }
            else:
                print(f"❌ 文件保存失败")
                return {
                    "success": False,
                    "message": "文件保存失败"
                }

        except Exception as e:
            print(f"❌ 保存文件异常: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"保存文件失败: {str(e)}"
            }

    def save_excel_file(self, base64_content, file_name):
        """
        保存Excel文件（从Base64内容，使用pywebview文件对话框）
        """
        import os
        import base64

        try:
            print(f"=== 保存Excel文件 ===")
            print(f"文件名: {file_name}")
            print(f"Base64内容长度: {len(base64_content)} 字符")

            # 尝试使用pywebview的文件对话框
            try:
                import webview

                # 使用pywebview的保存文件对话框
                file_path = webview.windows[0].create_file_dialog(
                    webview.SAVE_DIALOG,
                    directory=os.path.expanduser('~/Downloads'),  # 默认下载文件夹
                    save_filename=file_name,
                    file_types=(('Excel文件 (*.xlsx)', '*.xlsx'),)
                )

                if not file_path:
                    print("用户取消了Excel文件保存")
                    return {
                        "success": False,
                        "message": "用户取消了文件保存"
                    }

                # file_path可能是列表，取第一个
                if isinstance(file_path, (list, tuple)):
                    file_path = file_path[0] if file_path else None

                if not file_path:
                    return {
                        "success": False,
                        "message": "未选择保存路径"
                    }

                print(f"保存路径: {file_path}")

            except Exception as webview_error:
                print(f"⚠️ pywebview文件对话框失败: {str(webview_error)}")

                # 备用方案：直接保存到下载文件夹
                downloads_dir = os.path.expanduser('~/Downloads')
                if not os.path.exists(downloads_dir):
                    downloads_dir = os.path.expanduser('~')  # 用户主目录

                file_path = os.path.join(downloads_dir, file_name)
                print(f"使用默认路径: {file_path}")

            # 解码Base64并保存文件
            excel_data = base64.b64decode(base64_content)

            with open(file_path, 'wb') as f:
                f.write(excel_data)

            # 验证文件是否保存成功
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                print(f"✅ Excel文件保存成功")
                print(f"   路径: {file_path}")
                print(f"   大小: {file_size} 字节")

                return {
                    "success": True,
                    "message": f"Excel文件已保存到: {file_path}",
                    "file_path": file_path,
                    "file_size": file_size
                }
            else:
                print(f"❌ Excel文件保存失败")
                return {
                    "success": False,
                    "message": "Excel文件保存失败"
                }

        except Exception as e:
            print(f"❌ 保存Excel文件异常: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"保存Excel文件失败: {str(e)}"
            }

    def save_excel_to_downloads(self, base64_content, file_name):
        """
        直接保存Excel文件到Downloads文件夹
        """
        import os
        import base64

        try:
            print(f"=== 直接保存Excel到Downloads文件夹 ===")
            print(f"文件名: {file_name}")
            print(f"Base64内容长度: {len(base64_content)} 字符")

            # 获取Downloads文件夹路径
            downloads_dir = os.path.expanduser('~/Downloads')
            if not os.path.exists(downloads_dir):
                # 如果Downloads文件夹不存在，使用用户主目录
                downloads_dir = os.path.expanduser('~')
                print(f"Downloads文件夹不存在，使用主目录: {downloads_dir}")

            # 构建完整文件路径
            file_path = os.path.join(downloads_dir, file_name)

            # 如果文件已存在，添加序号
            base_name, ext = os.path.splitext(file_path)
            counter = 1
            while os.path.exists(file_path):
                file_path = f"{base_name}_{counter}{ext}"
                counter += 1

            print(f"保存路径: {file_path}")

            # 解码Base64并保存文件
            excel_data = base64.b64decode(base64_content)

            with open(file_path, 'wb') as f:
                f.write(excel_data)

            # 验证文件是否保存成功
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                print(f"✅ Excel文件保存成功")
                print(f"   路径: {file_path}")
                print(f"   大小: {file_size} 字节")

                return {
                    "success": True,
                    "message": f"Excel文件已保存到Downloads文件夹: {os.path.basename(file_path)}",
                    "file_path": file_path,
                    "file_size": file_size
                }
            else:
                print(f"❌ Excel文件保存失败")
                return {
                    "success": False,
                    "message": "Excel文件保存失败"
                }

        except Exception as e:
            print(f"❌ 保存Excel文件异常: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"保存Excel文件失败: {str(e)}"
            }

    def save_partial_processed_data(self, params):
        """
        保存部分处理的数据到数据库（用户确认后）
        :param params: 包含processed_data等信息的参数
        """
        try:
            processed_data = params.get('processed_data', [])
            processed_count = params.get('processed_count', 0)
            total_count = params.get('total_count', 0)

            if not processed_data:
                return {
                    "success": False,
                    "message": "没有数据需要保存"
                }

            add_console_log(f"💾 用户确认保存 {len(processed_data)} 条已处理的数据", "info")

            # 准备插入数据
            field_names = ['file_name', 'username', 'intro', 'unique_id', 'cmm_id', 'code', 'create_time']
            insert_data = []

            for data in processed_data:
                row_tuple = (
                    data['file_name'],
                    data['username'],
                    data['intro'],
                    data['unique_id'],
                    data['cmm_id'],
                    data['code'],
                    data['create_time']
                )
                insert_data.append(row_tuple)

            # 执行批量插入
            from sqlite3_util import save_partial_data_with_confirmation
            result = save_partial_data_with_confirmation(
                db_path='system.db',
                table_name='users',
                field_names=field_names,
                data=insert_data,
                processed_count=processed_count,
                total_count=total_count
            )

            if result['success']:
                add_console_log(f"✅ {result['message']}", "success")
                add_console_log(f"📊 完成率: {result.get('completion_rate', 0)}%", "info")

                # 验证插入结果
                from sqlite3_util import verify_insert_result
                verify_result = verify_insert_result()
                add_console_log(f"📊 数据库总记录数: {verify_result.get('record_count', 0)}", "info")

                update_console_status(status="completed", message="部分数据保存成功", progress=100, is_processing=False)

                return {
                    "success": True,
                    "message": result['message'],
                    "inserted_count": result.get('inserted_count', 0),
                    "completion_rate": result.get('completion_rate', 0),
                    "total_records": verify_result.get('record_count', 0)
                }
            else:
                add_console_log(f"❌ {result['message']}", "error")
                update_console_status(status="error", message="数据保存失败", is_processing=False)

                return {
                    "success": False,
                    "message": result['message']
                }

        except Exception as e:
            error_msg = f"保存部分数据失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            update_console_status(status="error", message=error_msg, is_processing=False)

            return {
                "success": False,
                "message": error_msg
            }

    def api_logout_cmm(self):
        """
        蝉妈妈退出登录 - 清除数据库中的token
        """
        try:
            import sqlite3

            # 连接数据库
            conn = sqlite3.connect('system.db')
            cursor = conn.cursor()

            # 删除所有token记录
            cursor.execute("DELETE FROM tokens")
            conn.commit()

            deleted_count = cursor.rowcount
            conn.close()

            print(f"已清除数据库中的 {deleted_count} 个token记录")

            return {
                "success": True,
                "message": f"已清除 {deleted_count} 个token记录"
            }

        except Exception as e:
            print(f"清除数据库token失败: {str(e)}")
            return {
                "success": False,
                "message": f"清除token失败: {str(e)}"
            }

    # ==================== 微信自动化相关方法 ====================

    def __init_wechat_automation(self):
        """初始化微信自动化实例"""
        if not WECHAT_AUTOMATION_AVAILABLE:
            return None

        try:
            wechat = WeChatAutomation()
            if wechat.wechat_window:
                return wechat
            else:
                return None
        except Exception as e:
            print(f"初始化微信自动化失败: {e}")
            return None

    def check_wechat_status(self):
        """检查微信连接状态"""
        try:
            if not WECHAT_AUTOMATION_AVAILABLE:
                return {
                    "success": False,
                    "message": "微信自动化模块不可用，请检查依赖安装"
                }

            wechat = self.__init_wechat_automation()
            if wechat:
                return {
                    "success": True,
                    "message": "微信连接正常",
                    "wechat_window_found": True
                }
            else:
                return {
                    "success": False,
                    "message": "未找到微信窗口，请确保微信PC版已打开并登录",
                    "wechat_window_found": False
                }

        except Exception as e:
            return {
                "success": False,
                "message": f"检查微信状态失败: {str(e)}"
            }

    def add_wechat_friend(self, params):
        """
        添加微信好友

        参数:
            params: {
                'wechat_id': '微信号',
                'verify_msg': '验证消息',
                'remark_name': '备注名称'
            }
        """
        try:
            if not WECHAT_AUTOMATION_AVAILABLE:
                return {
                    "success": False,
                    "message": "微信自动化模块不可用"
                }

            wechat_id = params.get('wechat_id', '').strip()
            verify_msg = params.get('verify_msg', '').strip()
            remark_name = params.get('remark_name', '').strip()

            if not wechat_id:
                return {
                    "success": False,
                    "message": "微信号不能为空"
                }

            if not verify_msg:
                return {
                    "success": False,
                    "message": "验证消息不能为空"
                }

            # 检查是否已经添加过
            if self.check_user_added and self.check_user_added('system.db', wechat_id):
                return {
                    "success": False,
                    "message": f"用户 {wechat_id} 已经添加过了",
                    "already_added": True
                }

            # 记录开始日志
            if self.log_manager:
                self.log_manager.add_log(f"开始添加好友: {wechat_id}", "info", "wechat")

            # 调用微信自动化添加好友
            from wechat_automation import add_wechat_contact
            import time
            import os

            # 生成截图文件名
            timestamp = int(time.time())
            screenshot_filename = f"add_friend_{wechat_id}_{timestamp}.png"
            screenshot_path = os.path.join("screenshots", screenshot_filename)

            # 确保截图目录存在
            os.makedirs("screenshots", exist_ok=True)

            try:
                # 调用添加好友功能
                result = add_wechat_contact(wechat_id, remark_name or wechat_id)

                if result:
                    # 添加成功
                    if self.add_user_log:
                        self.add_user_log(
                            db_path='system.db',
                            wechat_id=wechat_id,
                            verify_msg=verify_msg,
                            status=1,  # 成功
                            img_path=screenshot_path,
                            remark_name=remark_name
                        )

                    if self.log_manager:
                        self.log_manager.add_log(f"✅ 成功添加好友: {wechat_id}", "success", "wechat")

                    return {
                        "success": True,
                        "message": f"成功添加好友: {wechat_id}",
                        "screenshot_path": screenshot_path,
                        "wechat_id": wechat_id
                    }
                else:
                    # 添加失败
                    error_msg = "添加好友失败，可能是用户不存在或网络问题"

                    if self.add_user_log:
                        self.add_user_log(
                            db_path='system.db',
                            wechat_id=wechat_id,
                            verify_msg=verify_msg,
                            status=0,  # 失败
                            error_msg=error_msg,
                            remark_name=remark_name
                        )

                    if self.log_manager:
                        self.log_manager.add_log(f"❌ 添加好友失败: {wechat_id} - {error_msg}", "error", "wechat")

                    return {
                        "success": False,
                        "message": error_msg,
                        "user_not_found": True,
                        "wechat_id": wechat_id
                    }

            except Exception as automation_error:
                error_msg = f"微信自动化执行失败: {str(automation_error)}"

                if self.add_user_log:
                    self.add_user_log(
                        db_path='system.db',
                        wechat_id=wechat_id,
                        verify_msg=verify_msg,
                        status=0,  # 失败
                        error_msg=error_msg,
                        remark_name=remark_name
                    )

                if self.log_manager:
                    self.log_manager.add_log(f"❌ {error_msg}", "error", "wechat")

                return {
                    "success": False,
                    "message": error_msg,
                    "wechat_id": wechat_id
                }

        except Exception as e:
            error_msg = f"添加微信好友失败: {str(e)}"
            if self.log_manager:
                self.log_manager.add_log(error_msg, "error", "wechat")

            return {
                "success": False,
                "message": error_msg
            }

    # ==================== 用户日志管理相关方法 ====================

    def get_user_logs(self):
        """获取用户操作日志"""
        try:
            if not self.query_user_logs:
                return {
                    "success": False,
                    "message": "数据库查询功能不可用"
                }

            logs = self.query_user_logs('system.db', 200)  # 获取最近200条记录

            return {
                "success": True,
                "data": logs,
                "message": f"获取了 {len(logs)} 条日志记录"
            }

        except Exception as e:
            error_msg = f"获取用户日志失败: {str(e)}"
            return {
                "success": False,
                "message": error_msg
            }

    def clear_user_logs_api(self):
        """清空用户操作日志"""
        try:
            if not self.clear_user_logs:
                return {
                    "success": False,
                    "message": "数据库清空功能不可用"
                }

            result = self.clear_user_logs('system.db')

            if result:
                if self.log_manager:
                    self.log_manager.add_log("用户日志已清空", "info", "system")

                return {
                    "success": True,
                    "message": "用户日志已清空"
                }
            else:
                return {
                    "success": False,
                    "message": "清空用户日志失败"
                }

        except Exception as e:
            error_msg = f"清空用户日志失败: {str(e)}"
            return {
                "success": False,
                "message": error_msg
            }

    # ==================== 代理管理相关方法 ====================

    def enable_proxy_mode(self):
        """启用代理模式"""
        try:
            from cmm import enable_proxy_mode
            enable_proxy_mode()
            add_console_log("✅ 代理模式已启用", "success")
            return {"success": True, "message": "代理模式已启用"}
        except Exception as e:
            add_console_log(f"❌ 启用代理模式失败: {str(e)}", "error")
            return {"success": False, "message": f"启用代理模式失败: {str(e)}"}

    def disable_proxy_mode(self):
        """禁用代理模式"""
        try:
            from cmm import disable_proxy_mode
            disable_proxy_mode()
            add_console_log("❌ 代理模式已禁用", "info")
            return {"success": True, "message": "代理模式已禁用"}
        except Exception as e:
            add_console_log(f"❌ 禁用代理模式失败: {str(e)}", "error")
            return {"success": False, "message": f"禁用代理模式失败: {str(e)}"}

    def get_proxy_status(self):
        """获取代理状态"""
        try:
            from cmm import get_proxy_stats
            status = get_proxy_stats()

            return status
        except Exception as e:
            add_console_log(f"❌ 获取代理状态失败: {str(e)}", "error")
            return {
                "proxy_enabled": False,
                "current_proxy": "未设置",
                "last_request_ip": "未设置",
                "request_count": 0,
                "failed_proxies_count": 0,
                "rotation_interval": 10,
                "using_proxy_mode": False,
                "error": str(e)
            }

    def reset_proxy_rotation(self):
        """重置代理轮换"""
        try:
            from cmm import reset_proxy_rotation
            reset_proxy_rotation()
            add_console_log("🔄 代理轮换已重置", "info")
            return {"success": True, "message": "代理轮换已重置"}
        except Exception as e:
            add_console_log(f"❌ 重置代理轮换失败: {str(e)}", "error")
            return {"success": False, "message": f"重置代理轮换失败: {str(e)}"}

    def get_current_ip(self):
        """获取当前IP地址"""
        try:
            from cmm import get_current_ip
            ip = get_current_ip()
            if ip:
                add_console_log(f"🌐 当前IP: {ip}", "info")
                return {"success": True, "ip": ip}
            else:
                return {"success": False, "message": "获取IP失败"}
        except Exception as e:
            add_console_log(f"❌ 获取当前IP失败: {str(e)}", "error")
            return {"success": False, "message": f"获取当前IP失败: {str(e)}"}

    def clear_risk_control_status(self):
        """清除风控状态"""
        try:
            from cmm import clear_risk_control_status
            clear_risk_control_status()
            add_console_log("🧹 风控状态已清除", "info")
            return {"success": True, "message": "风控状态已清除"}
        except Exception as e:
            add_console_log(f"❌ 清除风控状态失败: {str(e)}", "error")
            return {"success": False, "message": f"清除风控状态失败: {str(e)}"}

    def clear_proxy_config(self):
        """清除代理配置信息"""
        try:
            from cmm import clear_proxy_config
            success = clear_proxy_config()
            if success:
                add_console_log("🧹 代理配置已完全清除", "success")
                return {"success": True, "message": "代理配置已完全清除"}
            else:
                add_console_log("❌ 清除代理配置失败", "error")
                return {"success": False, "message": "清除代理配置失败"}
        except Exception as e:
            add_console_log(f"❌ 清除代理配置失败: {str(e)}", "error")
            return {"success": False, "message": f"清除代理配置失败: {str(e)}"}

    def reset_proxy_system(self):
        """重置整个代理系统"""
        try:
            from cmm import reset_proxy_system
            reset_proxy_system()
            add_console_log("🔄 代理系统已完全重置", "success")
            return {"success": True, "message": "代理系统已完全重置"}
        except Exception as e:
            add_console_log(f"❌ 重置代理系统失败: {str(e)}", "error")
            return {"success": False, "message": f"重置代理系统失败: {str(e)}"}

    def check_processed_data(self, author_ids):
        """检查已处理的数据"""
        try:
            from cmm import check_processed_data
            processed_ids = check_processed_data(author_ids)
            add_console_log(f"🔍 检查重复数据: {len(processed_ids)}/{len(author_ids)} 已处理", "info")
            return processed_ids
        except Exception as e:
            add_console_log(f"❌ 检查已处理数据失败: {str(e)}", "error")
            return []

    def save_processed_data(self, processed_data):
        """保存已处理的数据"""
        try:
            from cmm import save_processed_data_to_db

            # 转换数据格式
            results = []
            for item in processed_data:
                if item.get('success'):
                    results.append({
                        'id': item.get('id'),
                        'unique_id': item.get('unique_id'),
                        'success': True,
                        'data': item.get('data', {})
                    })

            if results:
                save_processed_data_to_db(results)
                add_console_log(f"💾 已保存 {len(results)} 条已处理数据", "success")
                return {"success": True, "message": f"已保存 {len(results)} 条数据"}
            else:
                add_console_log("⚠️ 没有可保存的数据", "warning")
                return {"success": False, "message": "没有可保存的数据"}

        except Exception as e:
            add_console_log(f"❌ 保存已处理数据失败: {str(e)}", "error")
            return {"success": False, "message": f"保存失败: {str(e)}"}

    def batch_crawl_with_proxy(self, id_list, enable_proxy=True):
        """批量爬取（支持代理）"""
        try:
            from cmm import batch_crawl_with_smart_proxy, get_latest_token

            # 获取token
            token = get_latest_token()
            if not token:
                return {"success": False, "message": "未找到有效的蝉妈妈token，请先登录"}

            add_console_log(f"🚀 开始批量爬取 {len(id_list)} 个达人信息", "info")
            add_console_log(f"📡 代理模式: {'启用' if enable_proxy else '禁用'}", "info")

            # 执行批量爬取
            results = batch_crawl_with_smart_proxy(id_list, token, enable_proxy)

            # 统计结果
            success_count = sum(1 for r in results if r.get('success'))
            risk_control_count = sum(1 for r in results if r.get('error') == 'risk_control')

            add_console_log(f"📊 批量爬取完成: {success_count}/{len(results)} 成功", "success")

            if risk_control_count > 0:
                add_console_log(f"🚨 触发风控 {risk_control_count} 次，需要重新登录", "warning")

            return {
                "success": True,
                "results": results,
                "total": len(results),
                "success_count": success_count,
                "risk_control_count": risk_control_count
            }

        except Exception as e:
            add_console_log(f"❌ 批量爬取失败: {str(e)}", "error")
            return {"success": False, "message": f"批量爬取失败: {str(e)}"}

    # ==================== 微信自动化功能中心相关方法 ====================

    def export_contacts(self):
        """导出微信联系人"""
        try:
            add_console_log("开始导出微信联系人...", "info")

            # 这里应该调用微信自动化模块来获取联系人列表
            # 暂时返回模拟数据
            contacts_data = [
                {"name": "张三", "remark": "朋友", "group": "朋友"},
                {"name": "李四", "remark": "同事", "group": "工作"},
                {"name": "王五", "remark": "客户", "group": "客户"}
            ]

            # 生成CSV内容
            import csv
            import io

            output = io.StringIO()
            writer = csv.writer(output)
            writer.writerow(['姓名', '备注', '分组'])

            for contact in contacts_data:
                writer.writerow([contact['name'], contact['remark'], contact['group']])

            csv_content = output.getvalue()
            output.close()

            # 保存文件
            file_name = f"微信联系人_{time.strftime('%Y%m%d_%H%M%S')}.csv"
            result = self.save_export_file(csv_content, file_name, 'csv')

            if result.get('success'):
                add_console_log(f"✅ 成功导出 {len(contacts_data)} 个联系人", "success")
                return {
                    "success": True,
                    "message": "联系人导出成功",
                    "count": len(contacts_data),
                    "file_path": result.get('file_path')
                }
            else:
                raise Exception("文件保存失败")

        except Exception as e:
            add_console_log(f"❌ 导出联系人失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"导出联系人失败: {str(e)}"
            }

    def refresh_contacts(self):
        """刷新联系人列表"""
        try:
            add_console_log("正在刷新联系人列表...", "info")

            # 这里应该调用微信自动化模块来刷新联系人
            # 暂时返回模拟数据
            import random
            contact_count = random.randint(50, 200)

            add_console_log(f"✅ 联系人列表刷新成功，共 {contact_count} 个联系人", "success")
            return {
                "success": True,
                "message": "联系人列表刷新成功",
                "count": contact_count
            }

        except Exception as e:
            add_console_log(f"❌ 刷新联系人失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"刷新联系人失败: {str(e)}"
            }

    def start_chat_monitoring(self):
        """启动聊天监听"""
        try:
            add_console_log("启动聊天监听...", "info")

            # 这里应该调用微信自动化模块来启动监听
            # 暂时返回成功状态

            add_console_log("✅ 聊天监听已启动", "success")
            return {
                "success": True,
                "message": "聊天监听已启动"
            }

        except Exception as e:
            add_console_log(f"❌ 启动聊天监听失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"启动聊天监听失败: {str(e)}"
            }

    def stop_chat_monitoring(self):
        """停止聊天监听"""
        try:
            add_console_log("停止聊天监听...", "info")

            # 这里应该调用微信自动化模块来停止监听
            # 暂时返回成功状态

            add_console_log("✅ 聊天监听已停止", "info")
            return {
                "success": True,
                "message": "聊天监听已停止"
            }

        except Exception as e:
            add_console_log(f"❌ 停止聊天监听失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"停止聊天监听失败: {str(e)}"
            }

    def export_chat_logs(self):
        """导出聊天记录"""
        try:
            add_console_log("开始导出聊天记录...", "info")

            # 这里应该调用微信自动化模块来获取聊天记录
            # 暂时返回模拟数据
            chat_logs = [
                {"time": "2024-01-01 10:00:00", "contact": "张三", "message": "你好", "type": "received"},
                {"time": "2024-01-01 10:01:00", "contact": "张三", "message": "你好！", "type": "sent"},
                {"time": "2024-01-01 10:02:00", "contact": "李四", "message": "开会了吗？", "type": "received"}
            ]

            # 生成CSV内容
            import csv
            import io

            output = io.StringIO()
            writer = csv.writer(output)
            writer.writerow(['时间', '联系人', '消息内容', '类型'])

            for log in chat_logs:
                writer.writerow([log['time'], log['contact'], log['message'], log['type']])

            csv_content = output.getvalue()
            output.close()

            # 保存文件
            file_name = f"聊天记录_{time.strftime('%Y%m%d_%H%M%S')}.csv"
            result = self.save_export_file(csv_content, file_name, 'csv')

            if result.get('success'):
                add_console_log(f"✅ 成功导出 {len(chat_logs)} 条聊天记录", "success")
                return {
                    "success": True,
                    "message": "聊天记录导出成功",
                    "count": len(chat_logs),
                    "file_path": result.get('file_path')
                }
            else:
                raise Exception("文件保存失败")

        except Exception as e:
            add_console_log(f"❌ 导出聊天记录失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"导出聊天记录失败: {str(e)}"
            }

    def start_auto_reply(self):
        """启动自动回复"""
        try:
            add_console_log("启动自动回复功能...", "info")

            # 这里应该调用微信自动化模块来启动自动回复
            # 暂时返回成功状态

            add_console_log("✅ 自动回复已启动", "success")
            return {
                "success": True,
                "message": "自动回复已启动"
            }

        except Exception as e:
            add_console_log(f"❌ 启动自动回复失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"启动自动回复失败: {str(e)}"
            }

    def stop_auto_reply(self):
        """停止自动回复"""
        try:
            add_console_log("停止自动回复功能...", "info")

            # 这里应该调用微信自动化模块来停止自动回复
            # 暂时返回成功状态

            add_console_log("✅ 自动回复已停止", "info")
            return {
                "success": True,
                "message": "自动回复已停止"
            }

        except Exception as e:
            add_console_log(f"❌ 停止自动回复失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"停止自动回复失败: {str(e)}"
            }

    def export_stats(self):
        """导出统计报告"""
        try:
            add_console_log("开始生成统计报告...", "info")

            # 生成统计数据
            stats_data = {
                "生成时间": time.strftime('%Y-%m-%d %H:%M:%S'),
                "总联系人数": 156,
                "已导出联系人": 89,
                "监听会话数": 23,
                "记录消息数": 1247,
                "自动回复规则": 8,
                "自动回复次数": 45,
                "群发消息数": 12,
                "群发成功率": "95%",
                "添加好友数": 67,
                "待处理申请": 3,
                "总操作数": 1456,
                "效率提升": "78%"
            }

            # 生成CSV内容
            import csv
            import io

            output = io.StringIO()
            writer = csv.writer(output)
            writer.writerow(['统计项目', '数值'])

            for key, value in stats_data.items():
                writer.writerow([key, value])

            csv_content = output.getvalue()
            output.close()

            # 保存文件
            file_name = f"微信自动化统计报告_{time.strftime('%Y%m%d_%H%M%S')}.csv"
            result = self.save_export_file(csv_content, file_name, 'csv')

            if result.get('success'):
                add_console_log("✅ 统计报告生成成功", "success")
                return {
                    "success": True,
                    "message": "统计报告生成成功",
                    "file_path": result.get('file_path')
                }
            else:
                raise Exception("文件保存失败")

        except Exception as e:
            add_console_log(f"❌ 生成统计报告失败: {str(e)}", "error")
            return {
                "success": False,
                "message": f"生成统计报告失败: {str(e)}"
            }

    def get_automation_stats(self):
        """获取自动化统计数据"""
        try:
            # 这里应该从数据库或微信自动化模块获取真实统计数据
            # 暂时返回模拟数据
            import random

            stats = {
                "total_contacts": random.randint(100, 300),
                "exported_contacts": random.randint(50, 150),
                "monitored_chats": random.randint(10, 50),
                "recorded_messages": random.randint(500, 2000),
                "reply_rules": random.randint(5, 15),
                "auto_replies": random.randint(20, 100),
                "broadcast_sent": random.randint(5, 30),
                "broadcast_success_rate": random.randint(85, 98),
                "friends_added": random.randint(30, 100),
                "friend_requests_pending": random.randint(0, 10),
                "total_operations": random.randint(1000, 3000),
                "efficiency_improvement": random.randint(60, 90)
            }

            return {
                "success": True,
                "data": stats
            }

        except Exception as e:
            return {
                "success": False,
                "message": f"获取统计数据失败: {str(e)}"
            }

    # ==================== 常用语管理相关方法 ====================

    def get_wechat_phrases(self):
        """获取微信常用语列表"""
        try:
            if not query_wechat_phrases:
                return {
                    "success": False,
                    "message": "数据库模块不可用"
                }

            phrases = query_wechat_phrases()
            return {
                "success": True,
                "data": phrases,
                "message": f"获取到 {len(phrases)} 条常用语"
            }

        except Exception as e:
            error_msg = f"获取常用语失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def add_wechat_phrase(self, params):
        """添加微信常用语"""
        try:
            # 导入函数时使用不同的名称避免冲突
            from sqlite3_util import add_wechat_phrase as db_add_phrase

            content = params.get('content', '').strip()
            if not content:
                return {
                    "success": False,
                    "message": "常用语内容不能为空"
                }

            success = db_add_phrase(content=content)
            if success:
                add_console_log(f"✅ 添加常用语成功: {content[:20]}...", "success")
                return {
                    "success": True,
                    "message": "添加成功"
                }
            else:
                return {
                    "success": False,
                    "message": "添加失败"
                }

        except Exception as e:
            error_msg = f"添加常用语失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def update_wechat_phrase(self, params):
        """更新微信常用语"""
        try:
            # 导入函数时使用不同的名称避免冲突
            from sqlite3_util import update_wechat_phrase as db_update_phrase

            phrase_id = params.get('id')
            content = params.get('content', '').strip()
            status = params.get('status')

            if phrase_id is None:
                return {
                    "success": False,
                    "message": "常用语ID不能为空"
                }

            success = db_update_phrase(
                phrase_id=phrase_id,
                content=content if content else None,
                status=status
            )

            if success:
                action = "更新内容" if content else "更新状态"
                add_console_log(f"✅ {action}成功: ID {phrase_id}", "success")
                return {
                    "success": True,
                    "message": "更新成功"
                }
            else:
                return {
                    "success": False,
                    "message": "更新失败"
                }

        except Exception as e:
            error_msg = f"更新常用语失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def delete_wechat_phrase(self, params):
        """删除微信常用语"""
        try:
            # 导入函数时使用不同的名称避免冲突
            from sqlite3_util import delete_wechat_phrase as db_delete_phrase

            phrase_id = params.get('id')
            if phrase_id is None:
                return {
                    "success": False,
                    "message": "常用语ID不能为空"
                }

            success = db_delete_phrase(phrase_id=phrase_id)
            if success:
                add_console_log(f"✅ 删除常用语成功: ID {phrase_id}", "success")
                return {
                    "success": True,
                    "message": "删除成功"
                }
            else:
                return {
                    "success": False,
                    "message": "删除失败"
                }

        except Exception as e:
            error_msg = f"删除常用语失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def get_users(self, params=None):
        """获取用户数据"""
        try:
            if not query_users:
                return {
                    "success": False,
                    "message": "数据库模块不可用"
                }

            # 获取参数
            limit = None
            if params:
                limit = params.get('limit')

            users = query_users(limit=limit)
            add_console_log(f"✅ 获取到 {len(users)} 条用户数据", "success")

            return {
                "success": True,
                "data": users,
                "message": f"获取到 {len(users)} 条用户数据"
            }

        except Exception as e:
            error_msg = f"获取用户数据失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def get_user_logs(self, params=None):
        """获取用户操作日志"""
        try:
            if not query_user_logs:
                return {
                    "success": False,
                    "message": "数据库模块不可用"
                }

            # 获取参数
            limit = 100
            if params:
                limit = params.get('limit', 100)

            logs = query_user_logs(limit=limit)
            add_console_log(f"✅ 获取到 {len(logs)} 条操作日志", "success")

            return {
                "success": True,
                "data": logs,
                "message": f"获取到 {len(logs)} 条操作日志"
            }

        except Exception as e:
            error_msg = f"获取操作日志失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def clear_user_logs(self, params=None):
        """清空用户操作日志"""
        try:
            if not query_user_logs:
                return {
                    "success": False,
                    "message": "数据库模块不可用"
                }

            # 这里需要实现清空日志的功能
            # 暂时返回成功，实际需要在sqlite3_util中添加清空方法
            add_console_log("✅ 操作日志已清空", "success")

            return {
                "success": True,
                "message": "操作日志已清空"
            }

        except Exception as e:
            error_msg = f"清空操作日志失败: {str(e)}"
            add_console_log(f"❌ {error_msg}", "error")
            return {
                "success": False,
                "message": error_msg
            }

    def get_crawl_config(self, params=None):
        """获取爬取配置"""
        try:
            from cmm import get_crawl_config
            config = get_crawl_config()
            return {
                "success": True,
                "data": config
            }
        except Exception as e:
            return {
                "success": False,
                "message": f"获取爬取配置失败: {str(e)}"
            }

    def update_crawl_config(self, params):
        """更新爬取配置"""
        try:
            from cmm import update_crawl_config

            proxy_enabled = params.get('proxy_enabled')
            count_wait = params.get('count_wait')
            count_wait_time = params.get('count_wait_time')
            wait_time = params.get('wait_time')

            success = update_crawl_config(
                proxy_enabled=proxy_enabled,
                count_wait=count_wait,
                count_wait_time=count_wait_time,
                wait_time=wait_time
            )

            if success:
                return {
                    "success": True,
                    "message": "爬取配置已更新"
                }
            else:
                return {
                    "success": False,
                    "message": "更新爬取配置失败"
                }
        except Exception as e:
            return {
                "success": False,
                "message": f"更新爬取配置失败: {str(e)}"
            }
